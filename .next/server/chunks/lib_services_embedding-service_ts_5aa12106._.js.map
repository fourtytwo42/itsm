{"version":3,"sources":["../../../lib/services/embedding-service.ts"],"sourcesContent":["import prisma from '@/lib/prisma'\n\nconst OPENAI_API_URL = 'https://api.openai.com/v1/embeddings'\nconst EMBEDDING_MODEL = 'text-embedding-3-small' // 1536 dimensions\n\nfunction getApiKey(): string {\n  const key = process.env.OPENAI_API_KEY\n  if (!key) {\n    throw new Error('OPENAI_API_KEY is not set')\n  }\n  return key\n}\n\n/**\n * Generate embedding for text using OpenAI\n */\nexport async function generateEmbedding(text: string): Promise<number[]> {\n  const res = await fetch(OPENAI_API_URL, {\n    method: 'POST',\n    headers: {\n      'Content-Type': 'application/json',\n      Authorization: `Bearer ${getApiKey()}`,\n    },\n    body: JSON.stringify({\n      model: EMBEDDING_MODEL,\n      input: text.trim(),\n    }),\n  })\n\n  if (!res.ok) {\n    const text = await res.text()\n    throw new Error(`OpenAI Embedding API error: ${res.status} ${text}`)\n  }\n\n  const data = await res.json()\n  return data.data[0].embedding\n}\n\n/**\n * Chunk text into smaller pieces for embedding\n * Returns array of chunks with their text\n */\nexport function chunkText(text: string, maxChunkSize: number = 8000): string[] {\n  const chunks: string[] = []\n  const paragraphs = text.split(/\\n\\n+/)\n  let currentChunk = ''\n\n  for (const paragraph of paragraphs) {\n    if (currentChunk.length + paragraph.length + 2 <= maxChunkSize) {\n      currentChunk += (currentChunk ? '\\n\\n' : '') + paragraph\n    } else {\n      if (currentChunk) {\n        chunks.push(currentChunk)\n      }\n      // If paragraph itself is too long, split it\n      if (paragraph.length > maxChunkSize) {\n        const sentences = paragraph.split(/[.!?]+\\s+/)\n        let sentenceChunk = ''\n        for (const sentence of sentences) {\n          if (sentenceChunk.length + sentence.length + 2 <= maxChunkSize) {\n            sentenceChunk += (sentenceChunk ? '. ' : '') + sentence\n          } else {\n            if (sentenceChunk) chunks.push(sentenceChunk)\n            sentenceChunk = sentence\n          }\n        }\n        if (sentenceChunk) currentChunk = sentenceChunk\n      } else {\n        currentChunk = paragraph\n      }\n    }\n  }\n\n  if (currentChunk) {\n    chunks.push(currentChunk)\n  }\n\n  return chunks.length > 0 ? chunks : [text]\n}\n\n/**\n * Generate and store embeddings for a KB article\n */\nexport async function generateArticleEmbeddings(articleId: string): Promise<void> {\n  const article = await prisma.knowledgeBaseArticle.findUnique({\n    where: { id: articleId },\n  })\n\n  if (!article) {\n    throw new Error(`Article ${articleId} not found`)\n  }\n\n  // Delete existing embeddings\n  await prisma.$executeRawUnsafe(`DELETE FROM \"KBArticleEmbedding\" WHERE \"articleId\" = $1`, articleId)\n\n  // Create text to embed (title + content)\n  const textToEmbed = `${article.title}\\n\\n${article.content}`\n  const chunks = chunkText(textToEmbed)\n\n  // Generate embeddings for each chunk\n  for (let i = 0; i < chunks.length; i++) {\n    const chunk = chunks[i]\n    const embedding = await generateEmbedding(chunk)\n\n    // Store embedding using raw SQL since Prisma doesn't support vector type directly\n    const embeddingStr = `[${embedding.join(',')}]`\n    await prisma.$executeRawUnsafe(\n      `INSERT INTO \"KBArticleEmbedding\" (\"id\", \"articleId\", \"embedding\", \"chunkIndex\", \"chunkText\", \"createdAt\")\n       VALUES (gen_random_uuid(), $1, $2::vector, $3, $4, NOW())`,\n      articleId,\n      embeddingStr,\n      i,\n      chunk\n    )\n  }\n}\n\n/**\n * Semantic search for KB articles using vector similarity\n */\nexport async function semanticSearchArticles(\n  query: string,\n  options: {\n    tenantId?: string\n    organizationId?: string\n    limit?: number\n    userId?: string\n    userRoles?: string[]\n  } = {}\n): Promise<any[]> {\n  if (!query.trim()) return []\n\n  const limit = options.limit || 5\n\n  // Generate embedding for the query\n  const queryEmbedding = await generateEmbedding(query)\n  const queryEmbeddingStr = `[${queryEmbedding.join(',')}]`\n\n  // Build WHERE conditions\n  const conditions: string[] = [\"a.status = 'PUBLISHED'\"]\n  const params: any[] = [queryEmbeddingStr, limit]\n\n  // Filter by tenant if provided\n  if (options.tenantId) {\n    const paramIndex = params.length + 1\n    conditions.push(`EXISTS (\n      SELECT 1 FROM \"TenantKBArticle\" tka \n      WHERE tka.\"articleId\" = a.id AND tka.\"tenantId\" = $${paramIndex}\n    )`)\n    params.push(options.tenantId)\n  }\n\n  // Filter by organization if provided (and user is not GLOBAL_ADMIN)\n  if (options.organizationId && !options.userRoles?.includes('GLOBAL_ADMIN')) {\n    const paramIndex = params.length + 1\n    conditions.push(`a.\"organizationId\" = $${paramIndex}`)\n    params.push(options.organizationId)\n  }\n\n  const whereClause = 'WHERE ' + conditions.join(' AND ')\n\n  // Perform vector similarity search\n  const sql = `SELECT \n      a.*,\n      1 - (e.embedding <=> $1::vector) as similarity\n    FROM \"KnowledgeBaseArticle\" a\n    INNER JOIN \"KBArticleEmbedding\" e ON e.\"articleId\" = a.id\n    ${whereClause}\n    ORDER BY similarity DESC\n    LIMIT $2`\n\n  const results = await prisma.$queryRawUnsafe<any[]>(sql, ...params)\n\n  return results\n}\n"],"names":[],"mappings":"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"}