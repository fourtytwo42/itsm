{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 70, "column": 0}, "map": {"version":3,"sources":["file:///home/hendo420/itsm/lib/jwt.ts"],"sourcesContent":["import jwt from 'jsonwebtoken'\n\nconst JWT_SECRET = process.env.JWT_SECRET || 'default-secret-change-in-production'\nconst JWT_EXPIRES_IN = process.env.JWT_EXPIRES_IN || '3d'\nconst JWT_REFRESH_SECRET = process.env.JWT_REFRESH_SECRET || 'default-refresh-secret-change-in-production'\nconst JWT_REFRESH_EXPIRES_IN = process.env.JWT_REFRESH_EXPIRES_IN || '30d'\n\nexport interface TokenPayload {\n  userId: string\n  email: string\n  roles: string[]\n}\n\nexport interface RefreshTokenPayload {\n  userId: string\n  email: string\n}\n\nexport function signToken(payload: TokenPayload): string {\n  return jwt.sign(payload, JWT_SECRET, {\n    expiresIn: JWT_EXPIRES_IN,\n    algorithm: 'HS256',\n  })\n}\n\nexport function verifyToken(token: string): TokenPayload {\n  try {\n    const decoded = jwt.verify(token, JWT_SECRET, {\n      algorithms: ['HS256'],\n    }) as TokenPayload\n    return decoded\n  } catch (error) {\n    throw new Error('Invalid or expired token')\n  }\n}\n\nexport function signRefreshToken(payload: RefreshTokenPayload): string {\n  return jwt.sign(payload, JWT_REFRESH_SECRET, {\n    expiresIn: JWT_REFRESH_EXPIRES_IN,\n    algorithm: 'HS256',\n  })\n}\n\nexport function verifyRefreshToken(token: string): RefreshTokenPayload {\n  try {\n    const decoded = jwt.verify(token, JWT_REFRESH_SECRET, {\n      algorithms: ['HS256'],\n    }) as RefreshTokenPayload\n    return decoded\n  } catch (error) {\n    throw new Error('Invalid or expired refresh token')\n  }\n}\n\n"],"names":[],"mappings":";;;;;;;;;;AAAA;;AAEA,MAAM,aAAa,QAAQ,GAAG,CAAC,UAAU,IAAI;AAC7C,MAAM,iBAAiB,QAAQ,GAAG,CAAC,cAAc,IAAI;AACrD,MAAM,qBAAqB,QAAQ,GAAG,CAAC,kBAAkB,IAAI;AAC7D,MAAM,yBAAyB,QAAQ,GAAG,CAAC,sBAAsB,IAAI;AAa9D,SAAS,UAAU,OAAqB;IAC7C,OAAO,kJAAG,CAAC,IAAI,CAAC,SAAS,YAAY;QACnC,WAAW;QACX,WAAW;IACb;AACF;AAEO,SAAS,YAAY,KAAa;IACvC,IAAI;QACF,MAAM,UAAU,kJAAG,CAAC,MAAM,CAAC,OAAO,YAAY;YAC5C,YAAY;gBAAC;aAAQ;QACvB;QACA,OAAO;IACT,EAAE,OAAO,OAAO;QACd,MAAM,IAAI,MAAM;IAClB;AACF;AAEO,SAAS,iBAAiB,OAA4B;IAC3D,OAAO,kJAAG,CAAC,IAAI,CAAC,SAAS,oBAAoB;QAC3C,WAAW;QACX,WAAW;IACb;AACF;AAEO,SAAS,mBAAmB,KAAa;IAC9C,IAAI;QACF,MAAM,UAAU,kJAAG,CAAC,MAAM,CAAC,OAAO,oBAAoB;YACpD,YAAY;gBAAC;aAAQ;QACvB;QACA,OAAO;IACT,EAAE,OAAO,OAAO;QACd,MAAM,IAAI,MAAM;IAClB;AACF"}},
    {"offset": {"line": 132, "column": 0}, "map": {"version":3,"sources":["file:///home/hendo420/itsm/lib/prisma.ts"],"sourcesContent":["import { PrismaClient } from '@prisma/client'\n\nconst globalForPrisma = globalThis as unknown as {\n  prisma: PrismaClient | undefined\n}\n\nconst prisma = globalForPrisma.prisma ?? new PrismaClient({\n  log: process.env.NODE_ENV === 'development' ? ['query', 'error', 'warn'] : ['error'],\n})\n\nif (process.env.NODE_ENV !== 'production') {\n  globalForPrisma.prisma = prisma\n}\n\nexport default prisma\n"],"names":[],"mappings":";;;;AAAA;;AAEA,MAAM,kBAAkB;AAIxB,MAAM,SAAS,gBAAgB,MAAM,IAAI,IAAI,6IAAY,CAAC;IACxD,KAAK,uCAAyC;QAAC;QAAS;QAAS;KAAO,GAAG;AAC7E;AAEA,wCAA2C;IACzC,gBAAgB,MAAM,GAAG;AAC3B;uCAEe"}},
    {"offset": {"line": 154, "column": 0}, "map": {"version":3,"sources":["file:///home/hendo420/itsm/lib/auth.ts"],"sourcesContent":["import bcrypt from 'bcryptjs'\nimport prisma from './prisma'\nimport { signToken, signRefreshToken, type TokenPayload } from './jwt'\nimport { RoleName } from '@prisma/client'\n\nconst SALT_ROUNDS = 12\n\nexport async function hashPassword(password: string): Promise<string> {\n  return bcrypt.hash(password, SALT_ROUNDS)\n}\n\nexport async function verifyPassword(password: string, hash: string): Promise<boolean> {\n  return bcrypt.compare(password, hash)\n}\n\nexport interface LoginCredentials {\n  email: string\n  password: string\n}\n\nexport interface AuthResult {\n  user: {\n    id: string\n    email: string\n    firstName: string | null\n    lastName: string | null\n    roles: string[]\n  }\n  accessToken: string\n  refreshToken: string\n}\n\nexport async function authenticateUser(credentials: LoginCredentials): Promise<AuthResult> {\n  const { email, password } = credentials\n\n  // Find user with roles\n  const user = await prisma.user.findUnique({\n    where: { email },\n    include: {\n      roles: {\n        include: {\n          role: true,\n        },\n      },\n    },\n  })\n\n  if (!user || !user.passwordHash) {\n    throw new Error('Invalid email or password')\n  }\n\n  if (!user.isActive) {\n    throw new Error('Account is inactive')\n  }\n\n  const isValidPassword = await verifyPassword(password, user.passwordHash)\n  if (!isValidPassword) {\n    throw new Error('Invalid email or password')\n  }\n\n  // Update last login\n  await prisma.user.update({\n    where: { id: user.id },\n    data: { updatedAt: new Date() },\n  })\n\n  // Get user roles\n  const roles = user.roles.map((ur) => ur.role.name)\n\n  // Generate tokens\n  const tokenPayload: TokenPayload = {\n    userId: user.id,\n    email: user.email,\n    roles,\n  }\n\n  const accessToken = signToken(tokenPayload)\n  const refreshToken = signRefreshToken({\n    userId: user.id,\n    email: user.email,\n  })\n\n  return {\n    user: {\n      id: user.id,\n      email: user.email,\n      firstName: user.firstName,\n      lastName: user.lastName,\n      roles,\n    },\n    accessToken,\n    refreshToken,\n  }\n}\n\nexport interface RegisterData {\n  email: string\n  password: string\n  firstName?: string\n  lastName?: string\n}\n\nexport async function registerUser(data: RegisterData): Promise<AuthResult> {\n  const { email, password, firstName, lastName } = data\n\n  // Check if user already exists\n  const existingUser = await prisma.user.findUnique({\n    where: { email },\n  })\n\n  if (existingUser) {\n    throw new Error('User with this email already exists')\n  }\n\n  // Hash password\n  const passwordHash = await hashPassword(password)\n\n  // Create user with END_USER role by default\n  const user = await prisma.user.create({\n    data: {\n      email,\n      passwordHash,\n      firstName,\n      lastName,\n      roles: {\n        create: {\n          role: {\n            connect: {\n              name: RoleName.END_USER,\n            },\n          },\n        },\n      },\n    },\n    include: {\n      roles: {\n        include: {\n          role: true,\n        },\n      },\n    },\n  })\n\n  // Get user roles\n  const roles = user.roles.map((ur) => ur.role.name)\n\n  // Generate tokens\n  const tokenPayload: TokenPayload = {\n    userId: user.id,\n    email: user.email,\n    roles,\n  }\n\n  const accessToken = signToken(tokenPayload)\n  const refreshToken = signRefreshToken({\n    userId: user.id,\n    email: user.email,\n  })\n\n  return {\n    user: {\n      id: user.id,\n      email: user.email,\n      firstName: user.firstName,\n      lastName: user.lastName,\n      roles,\n    },\n    accessToken,\n    refreshToken,\n  }\n}\n\nexport async function getUserById(userId: string) {\n  return prisma.user.findUnique({\n    where: { id: userId },\n    include: {\n      roles: {\n        include: {\n          role: true,\n        },\n      },\n    },\n  })\n}\n\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 321, "column": 0}, "map": {"version":3,"sources":["file:///home/hendo420/itsm/lib/middleware/auth.ts"],"sourcesContent":["import { NextRequest } from 'next/server'\nimport { verifyToken, type TokenPayload } from '@/lib/jwt'\nimport { getUserById } from '@/lib/auth'\n\nexport interface AuthContext {\n  user: {\n    id: string\n    email: string\n    roles: string[]\n  }\n}\n\nexport async function getAuthContext(request: NextRequest): Promise<AuthContext | null> {\n  try {\n    const authHeader = request.headers.get('authorization')\n    \n    if (!authHeader || !authHeader.startsWith('Bearer ')) {\n      return null\n    }\n\n    const token = authHeader.substring(7)\n    const payload = verifyToken(token)\n\n    const user = await getUserById(payload.userId)\n    if (!user || !user.isActive) {\n      return null\n    }\n\n    const roles = user.roles.map((ur) => ur.role.name)\n\n    return {\n      user: {\n        id: user.id,\n        email: user.email,\n        roles,\n      },\n    }\n  } catch (error) {\n    return null\n  }\n}\n\nexport function requireAuth(authContext: AuthContext | null): asserts authContext is AuthContext {\n  if (!authContext) {\n    throw new Error('Unauthorized')\n  }\n}\n\nexport function requireRole(authContext: AuthContext, role: string): void {\n  requireAuth(authContext)\n  if (!authContext.user.roles.includes(role)) {\n    throw new Error('Forbidden: Insufficient permissions')\n  }\n}\n\nexport function requireAnyRole(authContext: AuthContext, roles: string[]): void {\n  requireAuth(authContext)\n  const hasRole = roles.some((role) => authContext.user.roles.includes(role))\n  if (!hasRole) {\n    throw new Error('Forbidden: Insufficient permissions')\n  }\n}\n\n"],"names":[],"mappings":";;;;;;;;;;AACA;AACA;;;AAUO,eAAe,eAAe,OAAoB;IACvD,IAAI;QACF,MAAM,aAAa,QAAQ,OAAO,CAAC,GAAG,CAAC;QAEvC,IAAI,CAAC,cAAc,CAAC,WAAW,UAAU,CAAC,YAAY;YACpD,OAAO;QACT;QAEA,MAAM,QAAQ,WAAW,SAAS,CAAC;QACnC,MAAM,UAAU,IAAA,2HAAW,EAAC;QAE5B,MAAM,OAAO,MAAM,IAAA,4HAAW,EAAC,QAAQ,MAAM;QAC7C,IAAI,CAAC,QAAQ,CAAC,KAAK,QAAQ,EAAE;YAC3B,OAAO;QACT;QAEA,MAAM,QAAQ,KAAK,KAAK,CAAC,GAAG,CAAC,CAAC,KAAO,GAAG,IAAI,CAAC,IAAI;QAEjD,OAAO;YACL,MAAM;gBACJ,IAAI,KAAK,EAAE;gBACX,OAAO,KAAK,KAAK;gBACjB;YACF;QACF;IACF,EAAE,OAAO,OAAO;QACd,OAAO;IACT;AACF;AAEO,SAAS,YAAY,WAA+B;IACzD,IAAI,CAAC,aAAa;QAChB,MAAM,IAAI,MAAM;IAClB;AACF;AAEO,SAAS,YAAY,WAAwB,EAAE,IAAY;IAChE,YAAY;IACZ,IAAI,CAAC,YAAY,IAAI,CAAC,KAAK,CAAC,QAAQ,CAAC,OAAO;QAC1C,MAAM,IAAI,MAAM;IAClB;AACF;AAEO,SAAS,eAAe,WAAwB,EAAE,KAAe;IACtE,YAAY;IACZ,MAAM,UAAU,MAAM,IAAI,CAAC,CAAC,OAAS,YAAY,IAAI,CAAC,KAAK,CAAC,QAAQ,CAAC;IACrE,IAAI,CAAC,SAAS;QACZ,MAAM,IAAI,MAAM;IAClB;AACF"}},
    {"offset": {"line": 381, "column": 0}, "map": {"version":3,"sources":["file:///home/hendo420/itsm/lib/services/analytics-service.ts"],"sourcesContent":["import prisma from '@/lib/prisma'\nimport { TicketStatus, TicketPriority } from '@prisma/client'\n\nexport interface DashboardMetrics {\n  totalTickets: number\n  openTickets: number\n  resolvedTickets: number\n  closedTickets: number\n  averageResolutionTime: number // minutes\n  slaCompliance: number // percentage\n  ticketsByPriority: Record<TicketPriority, number>\n  ticketsByStatus: Record<TicketStatus, number>\n  ticketsByDay?: Array<{ date: string; count: number }>\n}\n\nexport interface AgentPerformance {\n  id: string\n  name: string\n  email: string\n  ticketsResolved: number\n  ticketsAssigned: number\n  averageResolutionTime: number // minutes\n  slaCompliance: number // percentage\n  firstResponseTime: number // minutes average\n}\n\nexport interface ReportFilters {\n  startDate?: Date\n  endDate?: Date\n  agentId?: string\n  priority?: TicketPriority\n  status?: TicketStatus\n}\n\nexport async function getDashboardMetrics(filters?: ReportFilters): Promise<DashboardMetrics> {\n  const where: any = {}\n\n  if (filters?.startDate || filters?.endDate) {\n    where.createdAt = {}\n    if (filters.startDate) where.createdAt.gte = filters.startDate\n    if (filters.endDate) where.createdAt.lte = filters.endDate\n  }\n\n  if (filters?.priority) {\n    where.priority = filters.priority\n  }\n\n  if (filters?.status) {\n    where.status = filters.status\n  }\n\n  const [\n    totalTickets,\n    openTickets,\n    resolvedTickets,\n    closedTickets,\n    ticketsByPriority,\n    ticketsByStatus,\n    resolvedTicketsWithTime,\n    slaTracking,\n  ] = await Promise.all([\n    prisma.ticket.count({ where }),\n    prisma.ticket.count({\n      where: {\n        ...where,\n        status: { in: [TicketStatus.NEW, TicketStatus.IN_PROGRESS] },\n      },\n    }),\n    prisma.ticket.count({\n      where: {\n        ...where,\n        status: TicketStatus.RESOLVED,\n      },\n    }),\n    prisma.ticket.count({\n      where: {\n        ...where,\n        status: TicketStatus.CLOSED,\n      },\n    }),\n    prisma.ticket.groupBy({\n      by: ['priority'],\n      where,\n      _count: true,\n    }),\n    prisma.ticket.groupBy({\n      by: ['status'],\n      where,\n      _count: true,\n    }),\n    prisma.ticket.findMany({\n      where: {\n        ...where,\n        status: { in: [TicketStatus.RESOLVED, TicketStatus.CLOSED] },\n        closedAt: { not: null },\n        createdAt: { not: null },\n      },\n      select: {\n        createdAt: true,\n        closedAt: true,\n      },\n    }),\n    prisma.sLATracking.findMany({\n      where: filters?.startDate || filters?.endDate\n        ? {\n            createdAt: {\n              ...(filters.startDate && { gte: filters.startDate }),\n              ...(filters.endDate && { lte: filters.endDate }),\n            },\n          }\n        : {},\n      select: {\n        firstResponseBreached: true,\n        resolutionBreached: true,\n      },\n    }),\n  ])\n\n  // Calculate average resolution time\n  let averageResolutionTime = 0\n  if (resolvedTicketsWithTime.length > 0) {\n    const totalMinutes = resolvedTicketsWithTime.reduce((sum, ticket) => {\n      if (ticket.closedAt && ticket.createdAt) {\n        const diff = ticket.closedAt.getTime() - ticket.createdAt.getTime()\n        return sum + diff / (1000 * 60) // Convert to minutes\n      }\n      return sum\n    }, 0)\n    averageResolutionTime = totalMinutes / resolvedTicketsWithTime.length\n  }\n\n  // Calculate SLA compliance\n  let slaCompliance = 100\n  if (slaTracking.length > 0) {\n    const totalBreaches =\n      slaTracking.filter((t) => t.firstResponseBreached || t.resolutionBreached).length\n    slaCompliance = ((slaTracking.length - totalBreaches) / slaTracking.length) * 100\n  }\n\n  // Build tickets by priority\n  const priorityCounts: Record<TicketPriority, number> = {\n    LOW: 0,\n    MEDIUM: 0,\n    HIGH: 0,\n    CRITICAL: 0,\n  }\n  ticketsByPriority.forEach((item) => {\n    priorityCounts[item.priority] = item._count\n  })\n\n  // Build tickets by status\n  const statusCounts: Record<TicketStatus, number> = {\n    NEW: 0,\n    IN_PROGRESS: 0,\n    RESOLVED: 0,\n    CLOSED: 0,\n  }\n  ticketsByStatus.forEach((item) => {\n    statusCounts[item.status] = item._count\n  })\n\n  return {\n    totalTickets,\n    openTickets,\n    resolvedTickets,\n    closedTickets,\n    averageResolutionTime: Math.round(averageResolutionTime),\n    slaCompliance: Math.round(slaCompliance * 100) / 100,\n    ticketsByPriority: priorityCounts,\n    ticketsByStatus: statusCounts,\n  }\n}\n\nexport async function getAgentPerformance(filters?: ReportFilters): Promise<AgentPerformance[]> {\n  const where: any = {\n    assigneeId: { not: null },\n  }\n\n  if (filters?.startDate || filters?.endDate) {\n    where.createdAt = {}\n    if (filters.startDate) where.createdAt.gte = filters.startDate\n    if (filters.endDate) where.createdAt.lte = filters.endDate\n  }\n\n  if (filters?.agentId) {\n    where.assigneeId = filters.agentId\n  }\n\n  const tickets = await prisma.ticket.findMany({\n    where,\n    include: {\n      assignee: {\n        select: {\n          id: true,\n          email: true,\n          firstName: true,\n          lastName: true,\n        },\n      },\n      slaTracking: {\n        select: {\n          firstResponseActual: true,\n          firstResponseTarget: true,\n          resolutionActual: true,\n          resolutionTarget: true,\n          firstResponseBreached: true,\n          resolutionBreached: true,\n        },\n      },\n    },\n  })\n\n  // Group by agent\n  const agentMap = new Map<string, AgentPerformance>()\n\n  tickets.forEach((ticket) => {\n    if (!ticket.assignee) return\n\n    const agentId = ticket.assignee.id\n    if (!agentMap.has(agentId)) {\n      agentMap.set(agentId, {\n        id: agentId,\n        name: `${ticket.assignee.firstName || ''} ${ticket.assignee.lastName || ''}`.trim() || ticket.assignee.email,\n        email: ticket.assignee.email,\n        ticketsResolved: 0,\n        ticketsAssigned: 0,\n        averageResolutionTime: 0,\n        slaCompliance: 100,\n        firstResponseTime: 0,\n      })\n    }\n\n    const agent = agentMap.get(agentId)!\n    agent.ticketsAssigned++\n\n    if (ticket.status === TicketStatus.RESOLVED || ticket.status === TicketStatus.CLOSED) {\n      agent.ticketsResolved++\n\n      if (ticket.closedAt && ticket.createdAt) {\n        const resolutionTime = (ticket.closedAt.getTime() - ticket.createdAt.getTime()) / (1000 * 60)\n        agent.averageResolutionTime =\n          (agent.averageResolutionTime * (agent.ticketsResolved - 1) + resolutionTime) / agent.ticketsResolved\n      }\n    }\n\n    // Calculate first response time from SLA tracking\n    if (ticket.slaTracking?.firstResponseActual && ticket.slaTracking?.firstResponseTarget) {\n      const firstResponseTime =\n        (ticket.slaTracking.firstResponseActual.getTime() - ticket.createdAt.getTime()) / (1000 * 60)\n      agent.firstResponseTime =\n        (agent.firstResponseTime * (agent.ticketsAssigned - 1) + firstResponseTime) / agent.ticketsAssigned\n    }\n\n    // Calculate SLA compliance\n    if (ticket.slaTracking) {\n      const totalTickets = agent.ticketsAssigned\n      const breaches = (agent.ticketsResolved - agent.ticketsResolved) + // Previous breaches\n        (ticket.slaTracking.firstResponseBreached || ticket.slaTracking.resolutionBreached ? 1 : 0)\n      agent.slaCompliance = totalTickets > 0 ? ((totalTickets - breaches) / totalTickets) * 100 : 100\n    }\n  })\n\n  // Calculate final SLA compliance for each agent\n  const agents = Array.from(agentMap.values())\n  for (const agent of agents) {\n    const agentTickets = tickets.filter((t) => t.assigneeId === agent.id)\n    const slaTrackings = agentTickets\n      .map((t) => t.slaTracking)\n      .filter((t) => t !== null) as Array<{\n      firstResponseBreached: boolean\n      resolutionBreached: boolean\n    }>\n\n    if (slaTrackings.length > 0) {\n      const breaches = slaTrackings.filter((t) => t.firstResponseBreached || t.resolutionBreached).length\n      agent.slaCompliance = ((slaTrackings.length - breaches) / slaTrackings.length) * 100\n    }\n\n    agent.averageResolutionTime = Math.round(agent.averageResolutionTime)\n    agent.firstResponseTime = Math.round(agent.firstResponseTime)\n    agent.slaCompliance = Math.round(agent.slaCompliance * 100) / 100\n  }\n\n  return agents.sort((a, b) => b.ticketsResolved - a.ticketsResolved)\n}\n\nexport async function calculateMTTR(filters?: ReportFilters): Promise<number> {\n  const where: any = {\n    status: { in: [TicketStatus.RESOLVED, TicketStatus.CLOSED] },\n    closedAt: { not: null },\n  }\n\n  if (filters?.startDate || filters?.endDate) {\n    where.createdAt = {}\n    if (filters.startDate) where.createdAt.gte = filters.startDate\n    if (filters.endDate) where.createdAt.lte = filters.endDate\n  }\n\n  if (filters?.agentId) {\n    where.assigneeId = filters.agentId\n  }\n\n  const tickets = await prisma.ticket.findMany({\n    where,\n    select: {\n      createdAt: true,\n      closedAt: true,\n    },\n  })\n\n  const ticketsWithTime = tickets.filter((t) => t.closedAt && t.createdAt)\n\n  if (ticketsWithTime.length === 0) {\n    return 0\n  }\n\n  const totalMinutes = ticketsWithTime.reduce((sum, ticket) => {\n    const diff = ticket.closedAt!.getTime() - ticket.createdAt!.getTime()\n    return sum + diff / (1000 * 60) // Convert to minutes\n  }, 0)\n\n  return Math.round(totalMinutes / ticketsWithTime.length)\n}\n\nexport async function getTicketVolumeByDay(filters?: ReportFilters): Promise<Array<{ date: string; count: number }>> {\n  const where: any = {}\n\n  if (filters?.startDate || filters?.endDate) {\n    where.createdAt = {}\n    if (filters.startDate) where.createdAt.gte = filters.startDate\n    if (filters.endDate) where.createdAt.lte = filters.endDate\n  }\n\n  const tickets = await prisma.ticket.findMany({\n    where,\n    select: {\n      createdAt: true,\n    },\n    orderBy: {\n      createdAt: 'asc',\n    },\n  })\n\n  // Group by day\n  const dayMap = new Map<string, number>()\n\n  tickets.forEach((ticket) => {\n    const date = ticket.createdAt.toISOString().split('T')[0]\n    dayMap.set(date, (dayMap.get(date) || 0) + 1)\n  })\n\n  return Array.from(dayMap.entries())\n    .map(([date, count]) => ({ date, count }))\n    .sort((a, b) => a.date.localeCompare(b.date))\n}\n\nexport async function exportAnalyticsToCSV(\n  type: 'tickets' | 'agents' | 'sla',\n  filters?: ReportFilters\n): Promise<string> {\n  let csvData = ''\n\n  if (type === 'tickets') {\n    const where: any = {}\n    if (filters?.startDate || filters?.endDate) {\n      where.createdAt = {}\n      if (filters.startDate) where.createdAt.gte = filters.startDate\n      if (filters.endDate) where.createdAt.lte = filters.endDate\n    }\n\n    const tickets = await prisma.ticket.findMany({\n      where,\n      include: {\n        requester: {\n          select: {\n            email: true,\n            firstName: true,\n            lastName: true,\n          },\n        },\n        assignee: {\n          select: {\n            email: true,\n            firstName: true,\n            lastName: true,\n          },\n        },\n      },\n    })\n\n    csvData = [\n      'Ticket Number,Subject,Status,Priority,Requester,Assignee,Created At,Closed At',\n      ...tickets.map((t) =>\n        [\n          t.ticketNumber,\n          `\"${t.subject.replace(/\"/g, '\"\"')}\"`,\n          t.status,\n          t.priority,\n          t.requester.email,\n          t.assignee?.email || 'Unassigned',\n          t.createdAt.toISOString(),\n          t.closedAt?.toISOString() || '',\n        ].join(',')\n      ),\n    ].join('\\n')\n  } else if (type === 'agents') {\n    const agents = await getAgentPerformance(filters)\n    csvData = [\n      'Agent Name,Email,Tickets Resolved,Tickets Assigned,Average Resolution Time (min),SLA Compliance (%)',\n      ...agents.map((a) =>\n        [\n          `\"${a.name.replace(/\"/g, '\"\"')}\"`,\n          a.email,\n          a.ticketsResolved,\n          a.ticketsAssigned,\n          a.averageResolutionTime,\n          a.slaCompliance,\n        ].join(',')\n      ),\n    ].join('\\n')\n  } else if (type === 'sla') {\n    const where: any = {}\n    if (filters?.startDate || filters?.endDate) {\n      where.createdAt = {}\n      if (filters.startDate) where.createdAt.gte = filters.startDate\n      if (filters.endDate) where.createdAt.lte = filters.endDate\n    }\n\n    const tracking = await prisma.sLATracking.findMany({\n      where,\n      include: {\n        ticket: {\n          select: {\n            ticketNumber: true,\n            subject: true,\n          },\n        },\n        slaPolicy: {\n          select: {\n            name: true,\n            priority: true,\n          },\n        },\n      },\n    })\n\n    csvData = [\n      'Ticket Number,Subject,SLA Policy,First Response Target,First Response Actual,First Response Breached,Resolution Target,Resolution Actual,Resolution Breached',\n      ...tracking.map((t) =>\n        [\n          t.ticket.ticketNumber,\n          `\"${t.ticket.subject.replace(/\"/g, '\"\"')}\"`,\n          t.slaPolicy.name,\n          t.firstResponseTarget?.toISOString() || '',\n          t.firstResponseActual?.toISOString() || '',\n          t.firstResponseBreached ? 'Yes' : 'No',\n          t.resolutionTarget?.toISOString() || '',\n          t.resolutionActual?.toISOString() || '',\n          t.resolutionBreached ? 'Yes' : 'No',\n        ].join(',')\n      ),\n    ].join('\\n')\n  }\n\n  return csvData\n}\n\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 794, "column": 0}, "map": {"version":3,"sources":["file:///home/hendo420/itsm/app/api/v1/analytics/mttr/route.ts"],"sourcesContent":["import { NextRequest, NextResponse } from 'next/server'\nimport { getAuthContext, requireAuth } from '@/lib/middleware/auth'\nimport { calculateMTTR } from '@/lib/services/analytics-service'\n\nexport async function GET(request: NextRequest) {\n  try {\n    const authContext = await getAuthContext(request)\n    requireAuth(authContext)\n\n    const searchParams = request.nextUrl.searchParams\n    const startDate = searchParams.get('startDate')\n      ? new Date(searchParams.get('startDate')!)\n      : undefined\n    const endDate = searchParams.get('endDate')\n      ? new Date(searchParams.get('endDate')!)\n      : undefined\n    const agentId = searchParams.get('agentId') || undefined\n\n    const mttr = await calculateMTTR({\n      startDate,\n      endDate,\n      agentId,\n    })\n\n    return NextResponse.json(\n      {\n        success: true,\n        data: { mttr },\n      },\n      { status: 200 }\n    )\n  } catch (error) {\n    return NextResponse.json(\n      {\n        success: false,\n        error: {\n          code: 'INTERNAL_ERROR',\n          message: error instanceof Error ? error.message : 'An unexpected error occurred',\n        },\n      },\n      { status: 500 }\n    )\n  }\n}\n\n"],"names":[],"mappings":";;;;AAAA;AACA;AACA;;;;AAEO,eAAe,IAAI,OAAoB;IAC5C,IAAI;QACF,MAAM,cAAc,MAAM,IAAA,6IAAc,EAAC;QACzC,IAAA,0IAAW,EAAC;QAEZ,MAAM,eAAe,QAAQ,OAAO,CAAC,YAAY;QACjD,MAAM,YAAY,aAAa,GAAG,CAAC,eAC/B,IAAI,KAAK,aAAa,GAAG,CAAC,gBAC1B;QACJ,MAAM,UAAU,aAAa,GAAG,CAAC,aAC7B,IAAI,KAAK,aAAa,GAAG,CAAC,cAC1B;QACJ,MAAM,UAAU,aAAa,GAAG,CAAC,cAAc;QAE/C,MAAM,OAAO,MAAM,IAAA,0JAAa,EAAC;YAC/B;YACA;YACA;QACF;QAEA,OAAO,gJAAY,CAAC,IAAI,CACtB;YACE,SAAS;YACT,MAAM;gBAAE;YAAK;QACf,GACA;YAAE,QAAQ;QAAI;IAElB,EAAE,OAAO,OAAO;QACd,OAAO,gJAAY,CAAC,IAAI,CACtB;YACE,SAAS;YACT,OAAO;gBACL,MAAM;gBACN,SAAS,iBAAiB,QAAQ,MAAM,OAAO,GAAG;YACpD;QACF,GACA;YAAE,QAAQ;QAAI;IAElB;AACF"}}]
}