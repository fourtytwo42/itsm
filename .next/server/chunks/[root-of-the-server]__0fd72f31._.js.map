{"version":3,"sources":["../../../lib/prisma.ts","../../../lib/middleware/auth.ts","../../../lib/services/audit-service.ts","../../../lib/middleware/audit.ts","../../../lib/services/custom-role-service.ts","../../../lib/services/ticket-history-service.ts"],"sourcesContent":["import { PrismaClient } from '@prisma/client'\n\nconst globalForPrisma = globalThis as unknown as {\n  prisma: PrismaClient | undefined\n}\n\nconst prisma = globalForPrisma.prisma ?? new PrismaClient({\n  log: process.env.NODE_ENV === 'development' ? ['query', 'error', 'warn'] : ['error'],\n})\n\nif (process.env.NODE_ENV !== 'production') {\n  globalForPrisma.prisma = prisma\n}\n\nexport default prisma\n","import { NextRequest } from 'next/server'\nimport { verifyToken, type TokenPayload } from '@/lib/jwt'\nimport { getUserById } from '@/lib/auth'\n\nexport interface AuthContext {\n  user: {\n    id: string\n    email: string\n    roles: string[]\n    organizationId?: string\n    isGlobalAdmin: boolean\n  }\n  organizationId?: string // Current organization context\n}\n\nexport async function getAuthContext(request: NextRequest): Promise<AuthContext | null> {\n  try {\n    const authHeader = request.headers.get('authorization')\n    \n    if (!authHeader || !authHeader.startsWith('Bearer ')) {\n      return null\n    }\n\n    const token = authHeader.substring(7)\n    const payload = verifyToken(token)\n\n    const user = await getUserById(payload.userId)\n    if (!user || !user.isActive) {\n      return null\n    }\n\n    const roles = user.roles\n      .map((ur) => ur.role?.name || (ur.customRole ? `CUSTOM:${ur.customRole.name}` : null))\n      .filter((r): r is string => r !== null)\n    const isGlobalAdmin = roles.includes('GLOBAL_ADMIN')\n\n    return {\n      user: {\n        id: user.id,\n        email: user.email,\n        roles,\n        organizationId: user.organizationId || undefined,\n        isGlobalAdmin,\n      },\n      organizationId: user.organizationId || undefined,\n    }\n  } catch (error) {\n    return null\n  }\n}\n\nexport function requireAuth(authContext: AuthContext | null): asserts authContext is AuthContext {\n  if (!authContext) {\n    throw new Error('Unauthorized')\n  }\n}\n\nexport function requireRole(authContext: AuthContext, role: string): void {\n  requireAuth(authContext)\n  if (!authContext.user.roles.includes(role)) {\n    throw new Error('Forbidden: Insufficient permissions')\n  }\n}\n\nexport function requireAnyRole(authContext: AuthContext, roles: string[]): void {\n  requireAuth(authContext)\n  const hasRole = roles.some((role) => authContext.user.roles.includes(role))\n  if (!hasRole) {\n    throw new Error('Forbidden: Insufficient permissions')\n  }\n}\n\nexport async function requireOrganizationAccess(\n  authContext: AuthContext,\n  organizationId: string\n): Promise<void> {\n  requireAuth(authContext)\n\n  // Global admin can access any organization\n  if (authContext.user.isGlobalAdmin) {\n    return\n  }\n\n  // User must belong to the organization\n  if (authContext.user.organizationId !== organizationId) {\n    throw new Error('Forbidden: No access to this organization')\n  }\n}\n\n","import prisma from '@/lib/prisma'\nimport { AuditEventType } from '@prisma/client'\n\nexport interface AuditLogFilters {\n  organizationId?: string | null\n  eventType?: AuditEventType\n  entityType?: string\n  entityId?: string\n  userId?: string\n  startDate?: Date\n  endDate?: Date\n  page?: number\n  limit?: number\n}\n\nexport interface CreateAuditLogInput {\n  organizationId?: string | null\n  eventType: AuditEventType\n  entityType: string\n  entityId?: string | null\n  userId: string\n  userEmail: string\n  description: string\n  metadata?: any\n  ipAddress?: string\n  userAgent?: string\n}\n\nexport async function logEvent(input: CreateAuditLogInput) {\n  // Check if event should be logged\n  if (input.organizationId) {\n    const shouldLog = await shouldLogEvent(input.organizationId, input.eventType)\n    if (!shouldLog) {\n      return null // Event is disabled for this organization\n    }\n  }\n\n  return prisma.auditLog.create({\n    data: {\n      organizationId: input.organizationId,\n      eventType: input.eventType,\n      entityType: input.entityType,\n      entityId: input.entityId,\n      userId: input.userId,\n      userEmail: input.userEmail,\n      description: input.description,\n      metadata: input.metadata ? (input.metadata as any) : null,\n      ipAddress: input.ipAddress,\n      userAgent: input.userAgent,\n    },\n  })\n}\n\nexport async function getAuditLogs(filters: AuditLogFilters = {}) {\n  const {\n    organizationId,\n    eventType,\n    entityType,\n    entityId,\n    userId,\n    startDate,\n    endDate,\n    page = 1,\n    limit = 50,\n  } = filters\n\n  const skip = (page - 1) * limit\n\n  const where: any = {}\n\n  if (organizationId !== undefined) {\n    where.organizationId = organizationId\n  }\n\n  if (eventType) {\n    where.eventType = eventType\n  }\n\n  if (entityType) {\n    where.entityType = entityType\n  }\n\n  if (entityId) {\n    where.entityId = entityId\n  }\n\n  if (userId) {\n    where.userId = userId\n  }\n\n  if (startDate || endDate) {\n    where.createdAt = {}\n    if (startDate) {\n      where.createdAt.gte = startDate\n    }\n    if (endDate) {\n      where.createdAt.lte = endDate\n    }\n  }\n\n  const [logs, total] = await Promise.all([\n    prisma.auditLog.findMany({\n      where,\n      skip,\n      take: limit,\n      orderBy: { createdAt: 'desc' },\n      include: {\n        user: {\n          select: {\n            id: true,\n            email: true,\n            firstName: true,\n            lastName: true,\n          },\n        },\n        organization: {\n          select: {\n            id: true,\n            name: true,\n            slug: true,\n          },\n        },\n      },\n    }),\n    prisma.auditLog.count({ where }),\n  ])\n\n  return {\n    logs,\n    pagination: {\n      page,\n      limit,\n      total,\n      totalPages: Math.ceil(total / limit),\n    },\n  }\n}\n\nexport async function getAuditConfig(organizationId: string) {\n  return prisma.auditConfig.findUnique({\n    where: { organizationId },\n  })\n}\n\nexport async function updateAuditConfig(\n  organizationId: string,\n  config: {\n    enabled?: boolean\n    events?: AuditEventType[]\n    retentionDays?: number | null\n  }\n) {\n  return prisma.auditConfig.upsert({\n    where: { organizationId },\n    update: {\n      enabled: config.enabled,\n      events: config.events,\n      retentionDays: config.retentionDays,\n    },\n    create: {\n      organizationId,\n      enabled: config.enabled ?? true,\n      events: config.events ?? [],\n      retentionDays: config.retentionDays,\n    },\n  })\n}\n\nexport async function shouldLogEvent(\n  organizationId: string,\n  eventType: AuditEventType\n): Promise<boolean> {\n  const config = await prisma.auditConfig.findUnique({\n    where: { organizationId },\n  })\n\n  if (!config || !config.enabled) {\n    return false\n  }\n\n  return config.events.includes(eventType)\n}\n\n","import { NextRequest } from 'next/server'\nimport { logEvent, CreateAuditLogInput } from '@/lib/services/audit-service'\nimport { AuditEventType } from '@prisma/client'\n\nexport async function auditLog(\n  eventType: AuditEventType,\n  entityType: string,\n  entityId: string | null,\n  userId: string,\n  userEmail: string,\n  description: string,\n  metadata?: any,\n  request?: NextRequest\n) {\n  // Extract IP address and user agent from request\n  const ipAddress = request?.headers.get('x-forwarded-for') || \n                   request?.headers.get('x-real-ip') || \n                   'unknown'\n  const userAgent = request?.headers.get('user-agent') || 'unknown'\n\n  // Get organizationId from metadata if provided, otherwise null\n  const organizationId = metadata?.organizationId ?? null\n\n  try {\n    await logEvent({\n      organizationId,\n      eventType,\n      entityType,\n      entityId,\n      userId,\n      userEmail,\n      description,\n      metadata,\n      ipAddress: Array.isArray(ipAddress) ? ipAddress[0] : ipAddress,\n      userAgent,\n    })\n  } catch (error) {\n    // Don't throw - audit logging failures shouldn't break the application\n    console.error('Failed to log audit event:', error)\n  }\n}\n\n","import prisma from '@/lib/prisma'\nimport { RoleName } from '@prisma/client'\n\nexport interface CreateCustomRoleInput {\n  name: string\n  displayName: string\n  description?: string\n  organizationId: string\n  isActive?: boolean\n}\n\nexport interface UpdateCustomRoleInput {\n  name?: string\n  displayName?: string\n  description?: string\n  isActive?: boolean\n}\n\nexport async function createCustomRole(input: CreateCustomRoleInput) {\n  // Check if role with same name already exists in organization\n  const existing = await prisma.customRole.findUnique({\n    where: {\n      organizationId_name: {\n        organizationId: input.organizationId,\n        name: input.name,\n      },\n    },\n  })\n\n  if (existing) {\n    throw new Error(`Custom role with name \"${input.name}\" already exists in this organization`)\n  }\n\n  return prisma.customRole.create({\n    data: {\n      name: input.name,\n      displayName: input.displayName,\n      description: input.description,\n      organizationId: input.organizationId,\n      isActive: input.isActive ?? true,\n    },\n  })\n}\n\nexport async function getCustomRoleById(id: string) {\n  return prisma.customRole.findUnique({\n    where: { id },\n    include: {\n      organization: true,\n      userRoles: {\n        include: {\n          user: {\n            select: {\n              id: true,\n              email: true,\n              firstName: true,\n              lastName: true,\n            },\n          },\n        },\n      },\n    },\n  })\n}\n\nexport async function listCustomRoles(organizationId: string, filters?: { isActive?: boolean }) {\n  return prisma.customRole.findMany({\n    where: {\n      organizationId,\n      ...(filters?.isActive !== undefined && { isActive: filters.isActive }),\n    },\n    orderBy: {\n      displayName: 'asc',\n    },\n    include: {\n      _count: {\n        select: {\n          userRoles: true,\n        },\n      },\n    },\n  })\n}\n\nexport async function updateCustomRole(id: string, input: UpdateCustomRoleInput) {\n  const role = await prisma.customRole.findUnique({ where: { id } })\n  if (!role) {\n    throw new Error('Custom role not found')\n  }\n\n  // If name is being updated, check for conflicts\n  if (input.name && input.name !== role.name) {\n    const existing = await prisma.customRole.findUnique({\n      where: {\n        organizationId_name: {\n          organizationId: role.organizationId,\n          name: input.name,\n        },\n      },\n    })\n\n    if (existing) {\n      throw new Error(`Custom role with name \"${input.name}\" already exists in this organization`)\n    }\n  }\n\n  return prisma.customRole.update({\n    where: { id },\n    data: input,\n  })\n}\n\nexport async function deleteCustomRole(id: string) {\n  // Check if any users have this role\n  const userCount = await prisma.userRole.count({\n    where: { customRoleId: id },\n  })\n\n  if (userCount > 0) {\n    throw new Error(`Cannot delete custom role: ${userCount} user(s) are assigned to this role`)\n  }\n\n  return prisma.customRole.delete({\n    where: { id },\n  })\n}\n\nexport async function getAvailableRolesForEscalation(organizationId: string) {\n  const [systemRoles, customRoles] = await Promise.all([\n    // System roles that can receive escalations (AGENT, IT_MANAGER only - NOT ADMIN or END_USER)\n    Promise.resolve([\n      { type: 'system' as const, id: RoleName.AGENT, name: 'Agent', displayName: 'Agent' },\n      { type: 'system' as const, id: RoleName.IT_MANAGER, name: 'IT Manager', displayName: 'IT Manager' },\n    ]),\n    // Custom roles in the organization\n    prisma.customRole.findMany({\n      where: {\n        organizationId,\n        isActive: true,\n      },\n      select: {\n        id: true,\n        name: true,\n        displayName: true,\n      },\n    }).then(roles => roles.map(r => ({\n      type: 'custom' as const,\n      id: r.id,\n      name: r.name,\n      displayName: r.displayName,\n    }))),\n  ])\n\n  return [...systemRoles, ...customRoles]\n}\n\nexport async function getAvailableUsersForEscalation(\n  organizationId: string,\n  tenantId?: string | null\n) {\n  // Get users in the organization/tenant that are NOT ADMIN or END_USER\n  // They should be AGENT, IT_MANAGER, or have custom roles\n  const users = await prisma.user.findMany({\n    where: {\n      organizationId,\n      isActive: true,\n      deletedAt: null,\n      roles: {\n        some: {\n          OR: [\n            { role: { name: { in: [RoleName.AGENT, RoleName.IT_MANAGER] } } },\n            { customRole: { isNot: null } },\n          ],\n        },\n      },\n      // Exclude users with ADMIN or END_USER roles\n      NOT: {\n        roles: {\n          some: {\n            role: {\n              name: {\n                in: [RoleName.ADMIN, RoleName.END_USER],\n              },\n            },\n          },\n        },\n      },\n    },\n    include: {\n      roles: {\n        include: {\n          role: true,\n          customRole: true,\n        },\n      },\n      tenantAssignments: tenantId\n        ? {\n            where: {\n              tenantId,\n              category: null,\n            },\n          }\n        : undefined,\n    },\n  })\n\n  // Filter to only users assigned to the tenant if tenantId is provided\n  const filteredUsers = tenantId\n    ? users.filter((user) => {\n        // User must be assigned to the tenant or have no tenant assignments (org-wide)\n        return (\n          user.tenantAssignments.length > 0 ||\n          (user.tenantAssignments.length === 0 && !user.tenantId)\n        )\n      })\n    : users\n\n  return filteredUsers.map((user) => {\n    const roles = user.roles\n      .map((ur) => ur.role?.name || (ur.customRole ? `CUSTOM:${ur.customRole.name}` : null))\n      .filter((r): r is string => r !== null)\n\n    const primaryRole = user.roles.find((ur) => ur.role?.name)?.role?.name\n      || user.roles.find((ur) => ur.customRole)?.customRole?.displayName\n      || 'Unknown'\n\n    return {\n      id: user.id,\n      email: user.email,\n      firstName: user.firstName,\n      lastName: user.lastName,\n      roles,\n      primaryRole: typeof primaryRole === 'string' ? primaryRole : primaryRole,\n      displayName:\n        user.firstName && user.lastName\n          ? `${user.firstName} ${user.lastName}`\n          : user.email,\n    }\n  })\n}\n\n","import prisma from '@/lib/prisma'\nimport { TicketHistoryType } from '@prisma/client'\n\nexport interface CreateTicketHistoryInput {\n  ticketId: string\n  type: TicketHistoryType\n  userId: string\n  oldValue?: string | null\n  newValue?: string | null\n  note?: string | null\n  metadata?: Record<string, any> | null\n}\n\nexport async function createTicketHistory(input: CreateTicketHistoryInput) {\n  return prisma.ticketHistory.create({\n    data: {\n      ticketId: input.ticketId,\n      type: input.type,\n      userId: input.userId,\n      oldValue: input.oldValue || null,\n      newValue: input.newValue || null,\n      note: input.note || null,\n      metadata: input.metadata ? (input.metadata as any) : null,\n    },\n    include: {\n      user: {\n        select: {\n          id: true,\n          email: true,\n          firstName: true,\n          lastName: true,\n        },\n      },\n    },\n  })\n}\n\nexport async function getTicketHistory(ticketId: string) {\n  return prisma.ticketHistory.findMany({\n    where: { ticketId },\n    orderBy: { createdAt: 'desc' },\n    include: {\n      user: {\n        select: {\n          id: true,\n          email: true,\n          firstName: true,\n          lastName: true,\n        },\n      },\n    },\n  })\n}\n\n"],"names":[],"mappings":"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"}