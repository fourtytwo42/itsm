{"version":3,"sources":["../../../lib/prisma.ts","../../../lib/middleware/auth.ts"],"sourcesContent":["import { PrismaClient } from '@prisma/client'\n\nconst globalForPrisma = globalThis as unknown as {\n  prisma: PrismaClient | undefined\n}\n\nconst prisma = globalForPrisma.prisma ?? new PrismaClient({\n  log: process.env.NODE_ENV === 'development' ? ['query', 'error', 'warn'] : ['error'],\n})\n\nif (process.env.NODE_ENV !== 'production') {\n  globalForPrisma.prisma = prisma\n}\n\nexport default prisma\n","import { NextRequest } from 'next/server'\nimport { verifyToken, type TokenPayload } from '@/lib/jwt'\nimport { getUserById } from '@/lib/auth'\n\nexport interface AuthContext {\n  user: {\n    id: string\n    email: string\n    roles: string[]\n    organizationId?: string\n    isGlobalAdmin: boolean\n  }\n  organizationId?: string // Current organization context\n}\n\nexport async function getAuthContext(request: NextRequest): Promise<AuthContext | null> {\n  try {\n    const authHeader = request.headers.get('authorization')\n    \n    if (!authHeader || !authHeader.startsWith('Bearer ')) {\n      return null\n    }\n\n    const token = authHeader.substring(7)\n    const payload = verifyToken(token)\n\n    const user = await getUserById(payload.userId)\n    if (!user || !user.isActive) {\n      return null\n    }\n\n    const roles = user.roles.map((ur) => ur.role.name)\n    const isGlobalAdmin = roles.includes('GLOBAL_ADMIN')\n\n    return {\n      user: {\n        id: user.id,\n        email: user.email,\n        roles,\n        organizationId: user.organizationId || undefined,\n        isGlobalAdmin,\n      },\n      organizationId: user.organizationId || undefined,\n    }\n  } catch (error) {\n    return null\n  }\n}\n\nexport function requireAuth(authContext: AuthContext | null): asserts authContext is AuthContext {\n  if (!authContext) {\n    throw new Error('Unauthorized')\n  }\n}\n\nexport function requireRole(authContext: AuthContext, role: string): void {\n  requireAuth(authContext)\n  if (!authContext.user.roles.includes(role)) {\n    throw new Error('Forbidden: Insufficient permissions')\n  }\n}\n\nexport function requireAnyRole(authContext: AuthContext, roles: string[]): void {\n  requireAuth(authContext)\n  const hasRole = roles.some((role) => authContext.user.roles.includes(role))\n  if (!hasRole) {\n    throw new Error('Forbidden: Insufficient permissions')\n  }\n}\n\nexport async function requireOrganizationAccess(\n  authContext: AuthContext,\n  organizationId: string\n): Promise<void> {\n  requireAuth(authContext)\n\n  // Global admin can access any organization\n  if (authContext.user.isGlobalAdmin) {\n    return\n  }\n\n  // User must belong to the organization\n  if (authContext.user.organizationId !== organizationId) {\n    throw new Error('Forbidden: No access to this organization')\n  }\n}\n\n"],"names":[],"mappings":"6nCAAA,IAAA,EAAA,EAAA,CAAA,CAAA,OAMA,IAAM,EAJkB,AAIT,WAAgB,MAAM,EAAI,IAAI,EAAA,YAAY,CAAC,CACxD,IAA2E,CAAtE,AAAuE,QAAQ,AACtF,oBAMe,UAPiC,kBCNhD,IAAA,EAAA,EAAA,CAAA,CAAA,OACA,EAAA,EAAA,CAAA,CAAA,OAaO,eAAe,EAAe,CAAoB,EACvD,GAAI,CACF,IAAM,EAAa,EAAQ,OAAO,CAAC,GAAG,CAAC,iBAEvC,GAAI,CAAC,GAAc,CAAC,EAAW,UAAU,CAAC,WACxC,CADoD,MAC7C,KAGT,IAAM,EAAQ,EAAW,SAAS,CAAC,GAC7B,EAAU,CAAA,EAAA,EAAA,WAAA,AAAW,EAAC,GAEtB,EAAO,MAAM,CAAA,EAAA,EAAA,WAAA,AAAW,EAAC,EAAQ,MAAM,EAC7C,GAAI,CAAC,GAAQ,CAAC,EAAK,QAAQ,CACzB,CAD2B,MACpB,KAGT,IAAM,EAAQ,EAAK,KAAK,CAAC,GAAG,CAAC,AAAC,GAAO,EAAG,IAAI,CAAC,IAAI,EAC3C,EAAgB,EAAM,QAAQ,CAAC,gBAErC,MAAO,CACL,KAAM,CACJ,GAAI,EAAK,EAAE,CACX,MAAO,EAAK,KAAK,OACjB,EACA,eAAgB,EAAK,cAAc,OAAI,gBACvC,CACF,EACA,eAAgB,EAAK,cAAc,OAAI,CACzC,CACF,CAAE,MAAO,EAAO,CACd,OAAO,IACT,CACF,CAEO,SAAS,EAAY,CAA+B,EACzD,GAAI,CAAC,EACH,MAAM,AAAI,KADM,CACA,eAEpB,CAEO,SAAS,EAAY,CAAwB,CAAE,CAAY,EAEhE,GADA,EAAY,GACR,CAAC,EAAY,IAAI,CAAC,KAAK,CAAC,QAAQ,CAAC,GACnC,IAD0C,EACpC,AAAI,MAAM,sCAEpB,CAEO,SAAS,EAAe,CAAwB,CAAE,CAAe,EAGtE,GAFA,EAAY,GAER,CADY,AACX,EADiB,IAAI,CAAC,AAAC,EACd,CADuB,EAAY,IAAI,CAAC,KAAK,CAAC,QAAQ,CAAC,IAEnE,MAAM,AAAI,MAAM,sCAEpB"}