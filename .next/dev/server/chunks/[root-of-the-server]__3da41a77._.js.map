{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 52, "column": 0}, "map": {"version":3,"sources":["file:///home/hendo420/itsm/lib/prisma.ts"],"sourcesContent":["import { PrismaClient } from '@prisma/client'\n\nconst globalForPrisma = globalThis as unknown as {\n  prisma: PrismaClient | undefined\n}\n\nconst prisma = globalForPrisma.prisma ?? new PrismaClient({\n  log: process.env.NODE_ENV === 'development' ? ['query', 'error', 'warn'] : ['error'],\n})\n\nif (process.env.NODE_ENV !== 'production') {\n  globalForPrisma.prisma = prisma\n}\n\nexport default prisma\n"],"names":[],"mappings":";;;;AAAA;;AAEA,MAAM,kBAAkB;AAIxB,MAAM,SAAS,gBAAgB,MAAM,IAAI,IAAI,6IAAY,CAAC;IACxD,KAAK,uCAAyC;QAAC;QAAS;QAAS;KAAO,GAAG;AAC7E;AAEA,wCAA2C;IACzC,gBAAgB,MAAM,GAAG;AAC3B;uCAEe"}},
    {"offset": {"line": 140, "column": 0}, "map": {"version":3,"sources":["file:///home/hendo420/itsm/lib/jwt.ts"],"sourcesContent":["import jwt from 'jsonwebtoken'\n\nconst JWT_SECRET = process.env.JWT_SECRET || 'default-secret-change-in-production'\nconst JWT_EXPIRES_IN = process.env.JWT_EXPIRES_IN || '3d'\nconst JWT_REFRESH_SECRET = process.env.JWT_REFRESH_SECRET || 'default-refresh-secret-change-in-production'\nconst JWT_REFRESH_EXPIRES_IN = process.env.JWT_REFRESH_EXPIRES_IN || '30d'\n\nexport interface TokenPayload {\n  userId: string\n  email: string\n  roles: string[]\n}\n\nexport interface RefreshTokenPayload {\n  userId: string\n  email: string\n}\n\nexport function signToken(payload: TokenPayload): string {\n  return jwt.sign(payload, JWT_SECRET, {\n    expiresIn: JWT_EXPIRES_IN,\n    algorithm: 'HS256',\n  })\n}\n\nexport function verifyToken(token: string): TokenPayload {\n  try {\n    const decoded = jwt.verify(token, JWT_SECRET, {\n      algorithms: ['HS256'],\n    }) as TokenPayload\n    return decoded\n  } catch (error) {\n    throw new Error('Invalid or expired token')\n  }\n}\n\nexport function signRefreshToken(payload: RefreshTokenPayload): string {\n  return jwt.sign(payload, JWT_REFRESH_SECRET, {\n    expiresIn: JWT_REFRESH_EXPIRES_IN,\n    algorithm: 'HS256',\n  })\n}\n\nexport function verifyRefreshToken(token: string): RefreshTokenPayload {\n  try {\n    const decoded = jwt.verify(token, JWT_REFRESH_SECRET, {\n      algorithms: ['HS256'],\n    }) as RefreshTokenPayload\n    return decoded\n  } catch (error) {\n    throw new Error('Invalid or expired refresh token')\n  }\n}\n\n"],"names":[],"mappings":";;;;;;;;;;AAAA;;AAEA,MAAM,aAAa,QAAQ,GAAG,CAAC,UAAU,IAAI;AAC7C,MAAM,iBAAiB,QAAQ,GAAG,CAAC,cAAc,IAAI;AACrD,MAAM,qBAAqB,QAAQ,GAAG,CAAC,kBAAkB,IAAI;AAC7D,MAAM,yBAAyB,QAAQ,GAAG,CAAC,sBAAsB,IAAI;AAa9D,SAAS,UAAU,OAAqB;IAC7C,OAAO,kJAAG,CAAC,IAAI,CAAC,SAAS,YAAY;QACnC,WAAW;QACX,WAAW;IACb;AACF;AAEO,SAAS,YAAY,KAAa;IACvC,IAAI;QACF,MAAM,UAAU,kJAAG,CAAC,MAAM,CAAC,OAAO,YAAY;YAC5C,YAAY;gBAAC;aAAQ;QACvB;QACA,OAAO;IACT,EAAE,OAAO,OAAO;QACd,MAAM,IAAI,MAAM;IAClB;AACF;AAEO,SAAS,iBAAiB,OAA4B;IAC3D,OAAO,kJAAG,CAAC,IAAI,CAAC,SAAS,oBAAoB;QAC3C,WAAW;QACX,WAAW;IACb;AACF;AAEO,SAAS,mBAAmB,KAAa;IAC9C,IAAI;QACF,MAAM,UAAU,kJAAG,CAAC,MAAM,CAAC,OAAO,oBAAoB;YACpD,YAAY;gBAAC;aAAQ;QACvB;QACA,OAAO;IACT,EAAE,OAAO,OAAO;QACd,MAAM,IAAI,MAAM;IAClB;AACF"}},
    {"offset": {"line": 196, "column": 0}, "map": {"version":3,"sources":["file:///home/hendo420/itsm/lib/auth.ts"],"sourcesContent":["import bcrypt from 'bcryptjs'\nimport prisma from './prisma'\nimport { signToken, signRefreshToken, type TokenPayload } from './jwt'\nimport { RoleName } from '@prisma/client'\n\nconst SALT_ROUNDS = 12\n\nexport async function hashPassword(password: string): Promise<string> {\n  return bcrypt.hash(password, SALT_ROUNDS)\n}\n\nexport async function verifyPassword(password: string, hash: string): Promise<boolean> {\n  return bcrypt.compare(password, hash)\n}\n\nexport interface LoginCredentials {\n  email: string\n  password: string\n}\n\nexport interface AuthResult {\n  user: {\n    id: string\n    email: string\n    firstName: string | null\n    lastName: string | null\n    roles: string[]\n  }\n  accessToken: string\n  refreshToken: string\n}\n\nexport async function authenticateUser(credentials: LoginCredentials): Promise<AuthResult> {\n  const { email, password } = credentials\n\n  // Find user with roles\n  const user = await prisma.user.findUnique({\n    where: { email },\n    include: {\n      roles: {\n        include: {\n          role: true,\n        },\n      },\n    },\n  })\n\n  if (!user || !user.passwordHash) {\n    throw new Error('Invalid email or password')\n  }\n\n  if (!user.isActive) {\n    throw new Error('Account is inactive')\n  }\n\n  const isValidPassword = await verifyPassword(password, user.passwordHash)\n  if (!isValidPassword) {\n    throw new Error('Invalid email or password')\n  }\n\n  // Update last login\n  await prisma.user.update({\n    where: { id: user.id },\n    data: { updatedAt: new Date() },\n  })\n\n  // Get user roles\n  const roles = user.roles.map((ur) => ur.role.name)\n\n  // Generate tokens\n  const tokenPayload: TokenPayload = {\n    userId: user.id,\n    email: user.email,\n    roles,\n  }\n\n  const accessToken = signToken(tokenPayload)\n  const refreshToken = signRefreshToken({\n    userId: user.id,\n    email: user.email,\n  })\n\n  return {\n    user: {\n      id: user.id,\n      email: user.email,\n      firstName: user.firstName,\n      lastName: user.lastName,\n      roles,\n    },\n    accessToken,\n    refreshToken,\n  }\n}\n\nexport interface RegisterData {\n  email: string\n  password: string\n  firstName?: string\n  lastName?: string\n}\n\nexport async function registerUser(data: RegisterData): Promise<AuthResult> {\n  const { email, password, firstName, lastName } = data\n\n  // Check if user already exists\n  const existingUser = await prisma.user.findUnique({\n    where: { email },\n  })\n\n  if (existingUser) {\n    throw new Error('User with this email already exists')\n  }\n\n  // Hash password\n  const passwordHash = await hashPassword(password)\n\n  // Create user with END_USER role by default\n  const user = await prisma.user.create({\n    data: {\n      email,\n      passwordHash,\n      firstName,\n      lastName,\n      roles: {\n        create: {\n          role: {\n            connect: {\n              name: RoleName.END_USER,\n            },\n          },\n        },\n      },\n    },\n    include: {\n      roles: {\n        include: {\n          role: true,\n        },\n      },\n    },\n  })\n\n  // Get user roles\n  const roles = user.roles.map((ur) => ur.role.name)\n\n  // Generate tokens\n  const tokenPayload: TokenPayload = {\n    userId: user.id,\n    email: user.email,\n    roles,\n  }\n\n  const accessToken = signToken(tokenPayload)\n  const refreshToken = signRefreshToken({\n    userId: user.id,\n    email: user.email,\n  })\n\n  return {\n    user: {\n      id: user.id,\n      email: user.email,\n      firstName: user.firstName,\n      lastName: user.lastName,\n      roles,\n    },\n    accessToken,\n    refreshToken,\n  }\n}\n\nexport async function getUserById(userId: string) {\n  return prisma.user.findUnique({\n    where: { id: userId },\n    include: {\n      roles: {\n        include: {\n          role: true,\n        },\n      },\n    },\n  })\n}\n\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 363, "column": 0}, "map": {"version":3,"sources":["file:///home/hendo420/itsm/lib/websocket/server.ts"],"sourcesContent":["import { WebSocketServer, WebSocket } from 'ws'\nimport { verifyToken, type TokenPayload } from '@/lib/jwt'\nimport { getUserById } from '@/lib/auth'\nimport type { Server as HTTPServer } from 'http'\n\nexport interface WebSocketClient {\n  ws: WebSocket\n  userId: string\n  email: string\n  roles: string[]\n  subscriptions: Set<string> // Set of ticket IDs or other resource IDs\n}\n\nexport interface WebSocketMessage {\n  event: string\n  data?: any\n  error?: string\n}\n\nclass WSServer {\n  private wss: WebSocketServer | null = null\n  private clients: Map<string, WebSocketClient> = new Map() // userId -> client\n  private ticketSubscriptions: Map<string, Set<string>> = new Map() // ticketId -> Set of userIds\n\n  initialize(server: HTTPServer) {\n    this.wss = new WebSocketServer({ server, path: '/ws' })\n\n    this.wss.on('connection', async (ws: WebSocket, req) => {\n      try {\n        // Extract token from query string or Authorization header\n        const url = new URL(req.url || '', `http://${req.headers.host}`)\n        const token = url.searchParams.get('token') || this.extractTokenFromHeaders(req.headers)\n\n        if (!token) {\n          ws.close(1008, 'Authentication required')\n          return\n        }\n\n        // Verify JWT token\n        const payload = verifyToken(token)\n        const user = await getUserById(payload.userId)\n\n        if (!user || !user.isActive) {\n          ws.close(1008, 'Invalid or inactive user')\n          return\n        }\n\n        const roles = user.roles.map((ur) => ur.role.name)\n\n        const client: WebSocketClient = {\n          ws,\n          userId: user.id,\n          email: user.email,\n          roles,\n          subscriptions: new Set(),\n        }\n\n        // Store client\n        this.clients.set(user.id, client)\n\n        // Send connection confirmation\n        this.sendToClient(client, {\n          event: 'connected',\n          data: { userId: user.id, email: user.email },\n        })\n\n        // Handle messages\n        ws.on('message', (data: Buffer) => {\n          try {\n            const message: WebSocketMessage = JSON.parse(data.toString())\n            this.handleMessage(client, message)\n          } catch (error) {\n            this.sendToClient(client, {\n              event: 'error',\n              error: 'Invalid message format',\n            })\n          }\n        })\n\n        // Handle disconnect\n        ws.on('close', () => {\n          this.handleDisconnect(client)\n        })\n\n        // Handle errors\n        ws.on('error', (error) => {\n          console.error('WebSocket error:', error)\n          this.handleDisconnect(client)\n        })\n      } catch (error: any) {\n        console.error('WebSocket connection error:', error)\n        ws.close(1008, error.message || 'Connection failed')\n      }\n    })\n\n    console.log('WebSocket server initialized on /ws')\n  }\n\n  private extractTokenFromHeaders(headers: any): string | null {\n    const authHeader = headers.authorization || headers.Authorization\n    if (authHeader && typeof authHeader === 'string' && authHeader.startsWith('Bearer ')) {\n      return authHeader.substring(7)\n    }\n    return null\n  }\n\n  private handleMessage(client: WebSocketClient, message: WebSocketMessage) {\n    switch (message.event) {\n      case 'subscribe:ticket':\n        if (message.data?.ticketId) {\n          client.subscriptions.add(`ticket:${message.data.ticketId}`)\n          this.subscribeToTicket(message.data.ticketId, client.userId)\n          this.sendToClient(client, {\n            event: 'subscribed',\n            data: { resource: `ticket:${message.data.ticketId}` },\n          })\n        }\n        break\n\n      case 'unsubscribe:ticket':\n        if (message.data?.ticketId) {\n          client.subscriptions.delete(`ticket:${message.data.ticketId}`)\n          this.unsubscribeFromTicket(message.data.ticketId, client.userId)\n          this.sendToClient(client, {\n            event: 'unsubscribed',\n            data: { resource: `ticket:${message.data.ticketId}` },\n          })\n        }\n        break\n\n      case 'ping':\n        this.sendToClient(client, { event: 'pong' })\n        break\n\n      default:\n        this.sendToClient(client, {\n          event: 'error',\n          error: `Unknown event: ${message.event}`,\n        })\n    }\n  }\n\n  private subscribeToTicket(ticketId: string, userId: string) {\n    if (!this.ticketSubscriptions.has(ticketId)) {\n      this.ticketSubscriptions.set(ticketId, new Set())\n    }\n    this.ticketSubscriptions.get(ticketId)!.add(userId)\n  }\n\n  private unsubscribeFromTicket(ticketId: string, userId: string) {\n    const subscribers = this.ticketSubscriptions.get(ticketId)\n    if (subscribers) {\n      subscribers.delete(userId)\n      if (subscribers.size === 0) {\n        this.ticketSubscriptions.delete(ticketId)\n      }\n    }\n  }\n\n  private handleDisconnect(client: WebSocketClient) {\n    // Remove all ticket subscriptions\n    for (const sub of client.subscriptions) {\n      if (sub.startsWith('ticket:')) {\n        const ticketId = sub.replace('ticket:', '')\n        this.unsubscribeFromTicket(ticketId, client.userId)\n      }\n    }\n\n    this.clients.delete(client.userId)\n  }\n\n  private sendToClient(client: WebSocketClient, message: WebSocketMessage) {\n    if (client.ws.readyState === WebSocket.OPEN) {\n      client.ws.send(JSON.stringify(message))\n    }\n  }\n\n  // Public methods for broadcasting events\n  broadcastToUser(userId: string, event: string, data: any) {\n    const client = this.clients.get(userId)\n    if (client) {\n      this.sendToClient(client, { event, data })\n    }\n  }\n\n  broadcastToTicketSubscribers(ticketId: string, event: string, data: any) {\n    const subscribers = this.ticketSubscriptions.get(ticketId)\n    if (subscribers) {\n      subscribers.forEach((userId) => {\n        this.broadcastToUser(userId, event, data)\n      })\n    }\n  }\n\n  broadcastToAll(event: string, data: any) {\n    this.clients.forEach((client) => {\n      this.sendToClient(client, { event, data })\n    })\n  }\n\n  broadcastToRoles(roles: string[], event: string, data: any) {\n    this.clients.forEach((client) => {\n      if (roles.some((role) => client.roles.includes(role))) {\n        this.sendToClient(client, { event, data })\n      }\n    })\n  }\n\n  getClientCount(): number {\n    return this.clients.size\n  }\n\n  getTicketSubscriberCount(ticketId: string): number {\n    return this.ticketSubscriptions.get(ticketId)?.size || 0\n  }\n}\n\n// Singleton instance\nexport const wsServer = new WSServer()\n\n"],"names":[],"mappings":";;;;AAAA;AAAA;AAAA;AACA;AACA;;;;AAiBA,MAAM;IACI,MAA8B,KAAI;IAClC,UAAwC,IAAI,MAAM,mBAAmB;KAApB;IACjD,sBAAgD,IAAI,MAAM,6BAA6B;KAA9B;IAEjE,WAAW,MAAkB,EAAE;QAC7B,IAAI,CAAC,GAAG,GAAG,IAAI,mNAAe,CAAC;YAAE;YAAQ,MAAM;QAAM;QAErD,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,cAAc,OAAO,IAAe;YAC9C,IAAI;gBACF,0DAA0D;gBAC1D,MAAM,MAAM,IAAI,IAAI,IAAI,GAAG,IAAI,IAAI,CAAC,OAAO,EAAE,IAAI,OAAO,CAAC,IAAI,EAAE;gBAC/D,MAAM,QAAQ,IAAI,YAAY,CAAC,GAAG,CAAC,YAAY,IAAI,CAAC,uBAAuB,CAAC,IAAI,OAAO;gBAEvF,IAAI,CAAC,OAAO;oBACV,GAAG,KAAK,CAAC,MAAM;oBACf;gBACF;gBAEA,mBAAmB;gBACnB,MAAM,UAAU,IAAA,2HAAW,EAAC;gBAC5B,MAAM,OAAO,MAAM,IAAA,4HAAW,EAAC,QAAQ,MAAM;gBAE7C,IAAI,CAAC,QAAQ,CAAC,KAAK,QAAQ,EAAE;oBAC3B,GAAG,KAAK,CAAC,MAAM;oBACf;gBACF;gBAEA,MAAM,QAAQ,KAAK,KAAK,CAAC,GAAG,CAAC,CAAC,KAAO,GAAG,IAAI,CAAC,IAAI;gBAEjD,MAAM,SAA0B;oBAC9B;oBACA,QAAQ,KAAK,EAAE;oBACf,OAAO,KAAK,KAAK;oBACjB;oBACA,eAAe,IAAI;gBACrB;gBAEA,eAAe;gBACf,IAAI,CAAC,OAAO,CAAC,GAAG,CAAC,KAAK,EAAE,EAAE;gBAE1B,+BAA+B;gBAC/B,IAAI,CAAC,YAAY,CAAC,QAAQ;oBACxB,OAAO;oBACP,MAAM;wBAAE,QAAQ,KAAK,EAAE;wBAAE,OAAO,KAAK,KAAK;oBAAC;gBAC7C;gBAEA,kBAAkB;gBAClB,GAAG,EAAE,CAAC,WAAW,CAAC;oBAChB,IAAI;wBACF,MAAM,UAA4B,KAAK,KAAK,CAAC,KAAK,QAAQ;wBAC1D,IAAI,CAAC,aAAa,CAAC,QAAQ;oBAC7B,EAAE,OAAO,OAAO;wBACd,IAAI,CAAC,YAAY,CAAC,QAAQ;4BACxB,OAAO;4BACP,OAAO;wBACT;oBACF;gBACF;gBAEA,oBAAoB;gBACpB,GAAG,EAAE,CAAC,SAAS;oBACb,IAAI,CAAC,gBAAgB,CAAC;gBACxB;gBAEA,gBAAgB;gBAChB,GAAG,EAAE,CAAC,SAAS,CAAC;oBACd,QAAQ,KAAK,CAAC,oBAAoB;oBAClC,IAAI,CAAC,gBAAgB,CAAC;gBACxB;YACF,EAAE,OAAO,OAAY;gBACnB,QAAQ,KAAK,CAAC,+BAA+B;gBAC7C,GAAG,KAAK,CAAC,MAAM,MAAM,OAAO,IAAI;YAClC;QACF;QAEA,QAAQ,GAAG,CAAC;IACd;IAEQ,wBAAwB,OAAY,EAAiB;QAC3D,MAAM,aAAa,QAAQ,aAAa,IAAI,QAAQ,aAAa;QACjE,IAAI,cAAc,OAAO,eAAe,YAAY,WAAW,UAAU,CAAC,YAAY;YACpF,OAAO,WAAW,SAAS,CAAC;QAC9B;QACA,OAAO;IACT;IAEQ,cAAc,MAAuB,EAAE,OAAyB,EAAE;QACxE,OAAQ,QAAQ,KAAK;YACnB,KAAK;gBACH,IAAI,QAAQ,IAAI,EAAE,UAAU;oBAC1B,OAAO,aAAa,CAAC,GAAG,CAAC,CAAC,OAAO,EAAE,QAAQ,IAAI,CAAC,QAAQ,EAAE;oBAC1D,IAAI,CAAC,iBAAiB,CAAC,QAAQ,IAAI,CAAC,QAAQ,EAAE,OAAO,MAAM;oBAC3D,IAAI,CAAC,YAAY,CAAC,QAAQ;wBACxB,OAAO;wBACP,MAAM;4BAAE,UAAU,CAAC,OAAO,EAAE,QAAQ,IAAI,CAAC,QAAQ,EAAE;wBAAC;oBACtD;gBACF;gBACA;YAEF,KAAK;gBACH,IAAI,QAAQ,IAAI,EAAE,UAAU;oBAC1B,OAAO,aAAa,CAAC,MAAM,CAAC,CAAC,OAAO,EAAE,QAAQ,IAAI,CAAC,QAAQ,EAAE;oBAC7D,IAAI,CAAC,qBAAqB,CAAC,QAAQ,IAAI,CAAC,QAAQ,EAAE,OAAO,MAAM;oBAC/D,IAAI,CAAC,YAAY,CAAC,QAAQ;wBACxB,OAAO;wBACP,MAAM;4BAAE,UAAU,CAAC,OAAO,EAAE,QAAQ,IAAI,CAAC,QAAQ,EAAE;wBAAC;oBACtD;gBACF;gBACA;YAEF,KAAK;gBACH,IAAI,CAAC,YAAY,CAAC,QAAQ;oBAAE,OAAO;gBAAO;gBAC1C;YAEF;gBACE,IAAI,CAAC,YAAY,CAAC,QAAQ;oBACxB,OAAO;oBACP,OAAO,CAAC,eAAe,EAAE,QAAQ,KAAK,EAAE;gBAC1C;QACJ;IACF;IAEQ,kBAAkB,QAAgB,EAAE,MAAc,EAAE;QAC1D,IAAI,CAAC,IAAI,CAAC,mBAAmB,CAAC,GAAG,CAAC,WAAW;YAC3C,IAAI,CAAC,mBAAmB,CAAC,GAAG,CAAC,UAAU,IAAI;QAC7C;QACA,IAAI,CAAC,mBAAmB,CAAC,GAAG,CAAC,UAAW,GAAG,CAAC;IAC9C;IAEQ,sBAAsB,QAAgB,EAAE,MAAc,EAAE;QAC9D,MAAM,cAAc,IAAI,CAAC,mBAAmB,CAAC,GAAG,CAAC;QACjD,IAAI,aAAa;YACf,YAAY,MAAM,CAAC;YACnB,IAAI,YAAY,IAAI,KAAK,GAAG;gBAC1B,IAAI,CAAC,mBAAmB,CAAC,MAAM,CAAC;YAClC;QACF;IACF;IAEQ,iBAAiB,MAAuB,EAAE;QAChD,kCAAkC;QAClC,KAAK,MAAM,OAAO,OAAO,aAAa,CAAE;YACtC,IAAI,IAAI,UAAU,CAAC,YAAY;gBAC7B,MAAM,WAAW,IAAI,OAAO,CAAC,WAAW;gBACxC,IAAI,CAAC,qBAAqB,CAAC,UAAU,OAAO,MAAM;YACpD;QACF;QAEA,IAAI,CAAC,OAAO,CAAC,MAAM,CAAC,OAAO,MAAM;IACnC;IAEQ,aAAa,MAAuB,EAAE,OAAyB,EAAE;QACvE,IAAI,OAAO,EAAE,CAAC,UAAU,KAAK,6LAAS,CAAC,IAAI,EAAE;YAC3C,OAAO,EAAE,CAAC,IAAI,CAAC,KAAK,SAAS,CAAC;QAChC;IACF;IAEA,yCAAyC;IACzC,gBAAgB,MAAc,EAAE,KAAa,EAAE,IAAS,EAAE;QACxD,MAAM,SAAS,IAAI,CAAC,OAAO,CAAC,GAAG,CAAC;QAChC,IAAI,QAAQ;YACV,IAAI,CAAC,YAAY,CAAC,QAAQ;gBAAE;gBAAO;YAAK;QAC1C;IACF;IAEA,6BAA6B,QAAgB,EAAE,KAAa,EAAE,IAAS,EAAE;QACvE,MAAM,cAAc,IAAI,CAAC,mBAAmB,CAAC,GAAG,CAAC;QACjD,IAAI,aAAa;YACf,YAAY,OAAO,CAAC,CAAC;gBACnB,IAAI,CAAC,eAAe,CAAC,QAAQ,OAAO;YACtC;QACF;IACF;IAEA,eAAe,KAAa,EAAE,IAAS,EAAE;QACvC,IAAI,CAAC,OAAO,CAAC,OAAO,CAAC,CAAC;YACpB,IAAI,CAAC,YAAY,CAAC,QAAQ;gBAAE;gBAAO;YAAK;QAC1C;IACF;IAEA,iBAAiB,KAAe,EAAE,KAAa,EAAE,IAAS,EAAE;QAC1D,IAAI,CAAC,OAAO,CAAC,OAAO,CAAC,CAAC;YACpB,IAAI,MAAM,IAAI,CAAC,CAAC,OAAS,OAAO,KAAK,CAAC,QAAQ,CAAC,QAAQ;gBACrD,IAAI,CAAC,YAAY,CAAC,QAAQ;oBAAE;oBAAO;gBAAK;YAC1C;QACF;IACF;IAEA,iBAAyB;QACvB,OAAO,IAAI,CAAC,OAAO,CAAC,IAAI;IAC1B;IAEA,yBAAyB,QAAgB,EAAU;QACjD,OAAO,IAAI,CAAC,mBAAmB,CAAC,GAAG,CAAC,WAAW,QAAQ;IACzD;AACF;AAGO,MAAM,WAAW,IAAI"}},
    {"offset": {"line": 571, "column": 0}, "map": {"version":3,"sources":["file:///home/hendo420/itsm/lib/services/notification-service.ts"],"sourcesContent":["import prisma from '@/lib/prisma'\nimport { NotificationType, NotificationStatus } from '@prisma/client'\nimport { wsServer } from '@/lib/websocket/server'\n\nexport interface CreateNotificationParams {\n  userId: string\n  type: NotificationType\n  title: string\n  message: string\n  link?: string\n  metadata?: Record<string, any>\n}\n\nexport async function createNotification(params: CreateNotificationParams) {\n  const notification = await prisma.notification.create({\n    data: {\n      userId: params.userId,\n      type: params.type,\n      title: params.title,\n      message: params.message,\n      link: params.link,\n      metadata: params.metadata || {},\n    },\n  })\n\n  // Check user's notification preferences\n  const preferences = await prisma.notificationPreference.findUnique({\n    where: { userId: params.userId },\n  })\n\n  // Only send real-time notification if enabled\n  const shouldNotify = preferences\n    ? getPreferenceForType(preferences, params.type)\n    : true // Default to true if no preferences set\n\n  if (shouldNotify) {\n    // Send via WebSocket\n    wsServer.broadcastToUser(params.userId, 'notification:new', {\n      notification: {\n        id: notification.id,\n        type: notification.type,\n        title: notification.title,\n        message: notification.message,\n        link: notification.link,\n        createdAt: notification.createdAt,\n      },\n    })\n  }\n\n  return notification\n}\n\nfunction getPreferenceForType(\n  preferences: {\n    ticketCreated: boolean\n    ticketUpdated: boolean\n    ticketAssigned: boolean\n    ticketComment: boolean\n    changeRequestCreated: boolean\n    changeRequestApproved: boolean\n    changeRequestRejected: boolean\n    slaBreached: boolean\n    escalation: boolean\n  },\n  type: NotificationType\n): boolean {\n  switch (type) {\n    case NotificationType.TICKET_CREATED:\n      return preferences.ticketCreated\n    case NotificationType.TICKET_UPDATED:\n      return preferences.ticketUpdated\n    case NotificationType.TICKET_ASSIGNED:\n      return preferences.ticketAssigned\n    case NotificationType.TICKET_COMMENT:\n      return preferences.ticketComment\n    case NotificationType.CHANGE_REQUEST_CREATED:\n      return preferences.changeRequestCreated\n    case NotificationType.CHANGE_REQUEST_APPROVED:\n      return preferences.changeRequestApproved\n    case NotificationType.CHANGE_REQUEST_REJECTED:\n      return preferences.changeRequestRejected\n    case NotificationType.SLA_BREACHED:\n      return preferences.slaBreached\n    case NotificationType.ESCALATION:\n      return preferences.escalation\n    default:\n      return true\n  }\n}\n\nexport async function getNotifications(userId: string, options?: { limit?: number; unreadOnly?: boolean }) {\n  const where: any = { userId }\n  if (options?.unreadOnly) {\n    where.status = NotificationStatus.UNREAD\n  }\n\n  const notifications = await prisma.notification.findMany({\n    where,\n    orderBy: { createdAt: 'desc' },\n    take: options?.limit || 50,\n  })\n\n  return notifications\n}\n\nexport async function markAsRead(notificationId: string, userId: string) {\n  const notification = await prisma.notification.updateMany({\n    where: {\n      id: notificationId,\n      userId, // Ensure user owns the notification\n    },\n    data: {\n      status: NotificationStatus.READ,\n      readAt: new Date(),\n    },\n  })\n\n  return notification.count > 0\n}\n\nexport async function markAllAsRead(userId: string) {\n  await prisma.notification.updateMany({\n    where: {\n      userId,\n      status: NotificationStatus.UNREAD,\n    },\n    data: {\n      status: NotificationStatus.READ,\n      readAt: new Date(),\n    },\n  })\n}\n\nexport async function deleteNotification(notificationId: string, userId: string) {\n  const notification = await prisma.notification.deleteMany({\n    where: {\n      id: notificationId,\n      userId, // Ensure user owns the notification\n    },\n  })\n\n  return notification.count > 0\n}\n\nexport async function getUnreadCount(userId: string): Promise<number> {\n  return prisma.notification.count({\n    where: {\n      userId,\n      status: NotificationStatus.UNREAD,\n    },\n  })\n}\n\nexport async function getNotificationPreferences(userId: string) {\n  let preferences = await prisma.notificationPreference.findUnique({\n    where: { userId },\n  })\n\n  // Create default preferences if they don't exist\n  if (!preferences) {\n    preferences = await prisma.notificationPreference.create({\n      data: {\n        userId,\n        emailEnabled: true,\n        pushEnabled: true,\n        ticketCreated: true,\n        ticketUpdated: true,\n        ticketAssigned: true,\n        ticketComment: true,\n        changeRequestCreated: true,\n        changeRequestApproved: true,\n        changeRequestRejected: true,\n        slaBreached: true,\n        escalation: true,\n      },\n    })\n  }\n\n  return preferences\n}\n\nexport async function updateNotificationPreferences(\n  userId: string,\n  updates: Partial<{\n    emailEnabled: boolean\n    pushEnabled: boolean\n    ticketCreated: boolean\n    ticketUpdated: boolean\n    ticketAssigned: boolean\n    ticketComment: boolean\n    changeRequestCreated: boolean\n    changeRequestApproved: boolean\n    changeRequestRejected: boolean\n    slaBreached: boolean\n    escalation: boolean\n  }>\n) {\n  const preferences = await prisma.notificationPreference.upsert({\n    where: { userId },\n    update: updates,\n    create: {\n      userId,\n      emailEnabled: true,\n      pushEnabled: true,\n      ticketCreated: true,\n      ticketUpdated: true,\n      ticketAssigned: true,\n      ticketComment: true,\n      changeRequestCreated: true,\n      changeRequestApproved: true,\n      changeRequestRejected: true,\n      slaBreached: true,\n      escalation: true,\n      ...updates,\n    },\n  })\n\n  return preferences\n}\n\n// Helper functions to notify about ticket events\nexport async function notifyTicketCreated(ticketId: string, ticketNumber: string, assigneeId: string | null) {\n  if (assigneeId) {\n    await createNotification({\n      userId: assigneeId,\n      type: NotificationType.TICKET_ASSIGNED,\n      title: 'New Ticket Assigned',\n      message: `Ticket ${ticketNumber} has been assigned to you.`,\n      link: `/tickets/${ticketId}`,\n      metadata: { ticketId, ticketNumber },\n    })\n  }\n}\n\nexport async function notifyTicketUpdated(\n  ticketId: string,\n  ticketNumber: string,\n  changes: Record<string, any>,\n  userIds: string[]\n) {\n  for (const userId of userIds) {\n    await createNotification({\n      userId,\n      type: NotificationType.TICKET_UPDATED,\n      title: 'Ticket Updated',\n      message: `Ticket ${ticketNumber} has been updated.`,\n      link: `/tickets/${ticketId}`,\n      metadata: { ticketId, ticketNumber, changes },\n    })\n  }\n}\n\nexport async function notifyTicketAssigned(ticketId: string, ticketNumber: string, assigneeId: string) {\n  await createNotification({\n    userId: assigneeId,\n    type: NotificationType.TICKET_ASSIGNED,\n    title: 'Ticket Assigned',\n    message: `Ticket ${ticketNumber} has been assigned to you.`,\n    link: `/tickets/${ticketId}`,\n    metadata: { ticketId, ticketNumber },\n  })\n}\n\nexport async function notifyTicketComment(ticketId: string, ticketNumber: string, commentAuthorId: string, userIds: string[]) {\n  // Don't notify the comment author\n  const recipients = userIds.filter((id) => id !== commentAuthorId)\n\n  for (const userId of recipients) {\n    await createNotification({\n      userId,\n      type: NotificationType.TICKET_COMMENT,\n      title: 'New Comment',\n      message: `A new comment was added to ticket ${ticketNumber}.`,\n      link: `/tickets/${ticketId}`,\n      metadata: { ticketId, ticketNumber, commentAuthorId },\n    })\n  }\n}\n\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 837, "column": 0}, "map": {"version":3,"sources":["file:///home/hendo420/itsm/lib/services/ticket-service.ts"],"sourcesContent":["import prisma from '@/lib/prisma'\nimport { TicketStatus, TicketPriority } from '@prisma/client'\nimport { wsServer } from '@/lib/websocket/server'\nimport {\n  notifyTicketCreated,\n  notifyTicketUpdated,\n  notifyTicketAssigned,\n  notifyTicketComment,\n} from '@/lib/services/notification-service'\n\nexport interface CreateTicketInput {\n  subject: string\n  description: string\n  requesterId: string\n  priority?: TicketPriority\n  assigneeId?: string | null\n}\n\nexport interface UpdateTicketInput {\n  subject?: string\n  description?: string\n  status?: TicketStatus\n  priority?: TicketPriority\n  assigneeId?: string | null\n}\n\nexport interface AddCommentInput {\n  ticketId: string\n  authorId: string\n  body: string\n}\n\nexport async function generateTicketNumber(): Promise<string> {\n  const now = new Date()\n  const year = now.getFullYear()\n  const random = Math.floor(Math.random() * 9000) + 1000\n  return `TKT-${year}-${random.toString().padStart(4, '0')}`\n}\n\nexport async function createTicket(input: CreateTicketInput) {\n  const ticketNumber = await generateTicketNumber()\n\n  const ticket = await prisma.ticket.create({\n    data: {\n      ticketNumber,\n      subject: input.subject,\n      description: input.description,\n      requesterId: input.requesterId,\n      assigneeId: input.assigneeId || null,\n      priority: input.priority ?? TicketPriority.MEDIUM,\n      status: TicketStatus.NEW,\n    },\n    include: {\n      requester: { select: { id: true, email: true, firstName: true, lastName: true } },\n      assignee: { select: { id: true, email: true, firstName: true, lastName: true } },\n    },\n  })\n\n  // Broadcast WebSocket event\n  wsServer.broadcastToAll('ticket:created', {\n    ticket: {\n      id: ticket.id,\n      ticketNumber: ticket.ticketNumber,\n      subject: ticket.subject,\n      status: ticket.status,\n      priority: ticket.priority,\n      requester: ticket.requester,\n      assignee: ticket.assignee,\n      createdAt: ticket.createdAt,\n    },\n  })\n\n  // Create notification for assignee if assigned\n  if (ticket.assigneeId) {\n    await notifyTicketCreated(ticket.id, ticket.ticketNumber, ticket.assigneeId)\n  }\n\n  return ticket\n}\n\nexport async function listTickets(params?: {\n  status?: TicketStatus\n  priority?: TicketPriority\n  assigneeId?: string\n  requesterId?: string\n}) {\n  return prisma.ticket.findMany({\n    where: {\n      status: params?.status,\n      priority: params?.priority,\n      assigneeId: params?.assigneeId,\n      requesterId: params?.requesterId,\n    },\n    orderBy: { createdAt: 'desc' },\n    include: {\n      requester: { select: { id: true, email: true, firstName: true, lastName: true } },\n      assignee: { select: { id: true, email: true, firstName: true, lastName: true } },\n    },\n  })\n}\n\nexport async function getTicketById(id: string) {\n  return prisma.ticket.findUnique({\n    where: { id },\n    include: {\n      requester: { select: { id: true, email: true, firstName: true, lastName: true } },\n      assignee: { select: { id: true, email: true, firstName: true, lastName: true } },\n      comments: {\n        orderBy: { createdAt: 'asc' },\n        include: {\n          author: { select: { id: true, email: true, firstName: true, lastName: true } },\n        },\n      },\n    },\n  })\n}\n\nexport async function updateTicket(id: string, input: UpdateTicketInput) {\n  // Get current ticket to detect changes\n  const currentTicket = await prisma.ticket.findUnique({\n    where: { id },\n    include: {\n      requester: { select: { id: true } },\n      assignee: { select: { id: true } },\n    },\n  })\n\n  if (!currentTicket) {\n    throw new Error('Ticket not found')\n  }\n\n  const ticket = await prisma.ticket.update({\n    where: { id },\n    data: {\n      subject: input.subject,\n      description: input.description,\n      status: input.status,\n      priority: input.priority,\n      assigneeId: input.assigneeId,\n      closedAt: input.status === TicketStatus.CLOSED ? new Date() : undefined,\n    },\n    include: {\n      requester: { select: { id: true, email: true, firstName: true, lastName: true } },\n      assignee: { select: { id: true, email: true, firstName: true, lastName: true } },\n    },\n  })\n\n  // Detect changes\n  const changes: Record<string, any> = {}\n  if (input.status && input.status !== currentTicket.status) {\n    changes.status = { from: currentTicket.status, to: input.status }\n  }\n  if (input.priority && input.priority !== currentTicket.priority) {\n    changes.priority = { from: currentTicket.priority, to: input.priority }\n  }\n  if (input.assigneeId !== undefined && input.assigneeId !== currentTicket.assigneeId) {\n    changes.assigneeId = { from: currentTicket.assigneeId, to: input.assigneeId }\n  }\n\n  // Broadcast WebSocket event\n  wsServer.broadcastToTicketSubscribers(id, 'ticket:updated', {\n    ticket: {\n      id: ticket.id,\n      ticketNumber: ticket.ticketNumber,\n      subject: ticket.subject,\n      status: ticket.status,\n      priority: ticket.priority,\n      requester: ticket.requester,\n      assignee: ticket.assignee,\n      updatedAt: ticket.updatedAt,\n    },\n    changes,\n  })\n\n  // Notify relevant users\n  const userIds: string[] = []\n  if (ticket.requesterId) userIds.push(ticket.requesterId)\n  if (ticket.assigneeId) userIds.push(ticket.assigneeId)\n  if (currentTicket.requesterId && !userIds.includes(currentTicket.requesterId)) {\n    userIds.push(currentTicket.requesterId)\n  }\n  if (currentTicket.assigneeId && !userIds.includes(currentTicket.assigneeId)) {\n    userIds.push(currentTicket.assigneeId)\n  }\n\n  if (Object.keys(changes).length > 0 && userIds.length > 0) {\n    await notifyTicketUpdated(ticket.id, ticket.ticketNumber, changes, userIds)\n  }\n\n  // Handle assignment change\n  if (input.assigneeId !== undefined && input.assigneeId !== currentTicket.assigneeId) {\n    if (input.assigneeId) {\n      await notifyTicketAssigned(ticket.id, ticket.ticketNumber, input.assigneeId)\n      wsServer.broadcastToUser(input.assigneeId, 'ticket:assigned', {\n        ticket: {\n          id: ticket.id,\n          ticketNumber: ticket.ticketNumber,\n          subject: ticket.subject,\n        },\n      })\n    }\n  }\n\n  return ticket\n}\n\nexport async function addTicketComment(input: AddCommentInput) {\n  // Get ticket to find all relevant users\n  const ticket = await prisma.ticket.findUnique({\n    where: { id: input.ticketId },\n    include: {\n      requester: { select: { id: true } },\n      assignee: { select: { id: true } },\n      comments: {\n        select: { authorId: true },\n        distinct: ['authorId'],\n      },\n    },\n  })\n\n  if (!ticket) {\n    throw new Error('Ticket not found')\n  }\n\n  const comment = await prisma.ticketComment.create({\n    data: {\n      ticketId: input.ticketId,\n      authorId: input.authorId,\n      body: input.body,\n    },\n    include: {\n      author: { select: { id: true, email: true, firstName: true, lastName: true } },\n    },\n  })\n\n  // Broadcast WebSocket event\n  wsServer.broadcastToTicketSubscribers(input.ticketId, 'ticket:comment', {\n    ticketId: input.ticketId,\n    comment: {\n      id: comment.id,\n      body: comment.body,\n      author: comment.author,\n      createdAt: comment.createdAt,\n    },\n  })\n\n  // Notify relevant users (requester, assignee, and other commenters)\n  const userIds: string[] = []\n  if (ticket.requesterId) userIds.push(ticket.requesterId)\n  if (ticket.assigneeId) userIds.push(ticket.assigneeId)\n  ticket.comments.forEach((c) => {\n    if (c.authorId && !userIds.includes(c.authorId)) {\n      userIds.push(c.authorId)\n    }\n  })\n\n  if (userIds.length > 0) {\n    await notifyTicketComment(\n      input.ticketId,\n      ticket.ticketNumber,\n      input.authorId,\n      userIds\n    )\n  }\n\n  return comment\n}\n\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 1176, "column": 0}, "map": {"version":3,"sources":["file:///home/hendo420/itsm/lib/middleware/auth.ts"],"sourcesContent":["import { NextRequest } from 'next/server'\nimport { verifyToken, type TokenPayload } from '@/lib/jwt'\nimport { getUserById } from '@/lib/auth'\n\nexport interface AuthContext {\n  user: {\n    id: string\n    email: string\n    roles: string[]\n  }\n}\n\nexport async function getAuthContext(request: NextRequest): Promise<AuthContext | null> {\n  try {\n    const authHeader = request.headers.get('authorization')\n    \n    if (!authHeader || !authHeader.startsWith('Bearer ')) {\n      return null\n    }\n\n    const token = authHeader.substring(7)\n    const payload = verifyToken(token)\n\n    const user = await getUserById(payload.userId)\n    if (!user || !user.isActive) {\n      return null\n    }\n\n    const roles = user.roles.map((ur) => ur.role.name)\n\n    return {\n      user: {\n        id: user.id,\n        email: user.email,\n        roles,\n      },\n    }\n  } catch (error) {\n    return null\n  }\n}\n\nexport function requireAuth(authContext: AuthContext | null): asserts authContext is AuthContext {\n  if (!authContext) {\n    throw new Error('Unauthorized')\n  }\n}\n\nexport function requireRole(authContext: AuthContext, role: string): void {\n  requireAuth(authContext)\n  if (!authContext.user.roles.includes(role)) {\n    throw new Error('Forbidden: Insufficient permissions')\n  }\n}\n\nexport function requireAnyRole(authContext: AuthContext, roles: string[]): void {\n  requireAuth(authContext)\n  const hasRole = roles.some((role) => authContext.user.roles.includes(role))\n  if (!hasRole) {\n    throw new Error('Forbidden: Insufficient permissions')\n  }\n}\n\n"],"names":[],"mappings":";;;;;;;;;;AACA;AACA;;;AAUO,eAAe,eAAe,OAAoB;IACvD,IAAI;QACF,MAAM,aAAa,QAAQ,OAAO,CAAC,GAAG,CAAC;QAEvC,IAAI,CAAC,cAAc,CAAC,WAAW,UAAU,CAAC,YAAY;YACpD,OAAO;QACT;QAEA,MAAM,QAAQ,WAAW,SAAS,CAAC;QACnC,MAAM,UAAU,IAAA,2HAAW,EAAC;QAE5B,MAAM,OAAO,MAAM,IAAA,4HAAW,EAAC,QAAQ,MAAM;QAC7C,IAAI,CAAC,QAAQ,CAAC,KAAK,QAAQ,EAAE;YAC3B,OAAO;QACT;QAEA,MAAM,QAAQ,KAAK,KAAK,CAAC,GAAG,CAAC,CAAC,KAAO,GAAG,IAAI,CAAC,IAAI;QAEjD,OAAO;YACL,MAAM;gBACJ,IAAI,KAAK,EAAE;gBACX,OAAO,KAAK,KAAK;gBACjB;YACF;QACF;IACF,EAAE,OAAO,OAAO;QACd,OAAO;IACT;AACF;AAEO,SAAS,YAAY,WAA+B;IACzD,IAAI,CAAC,aAAa;QAChB,MAAM,IAAI,MAAM;IAClB;AACF;AAEO,SAAS,YAAY,WAAwB,EAAE,IAAY;IAChE,YAAY;IACZ,IAAI,CAAC,YAAY,IAAI,CAAC,KAAK,CAAC,QAAQ,CAAC,OAAO;QAC1C,MAAM,IAAI,MAAM;IAClB;AACF;AAEO,SAAS,eAAe,WAAwB,EAAE,KAAe;IACtE,YAAY;IACZ,MAAM,UAAU,MAAM,IAAI,CAAC,CAAC,OAAS,YAAY,IAAI,CAAC,KAAK,CAAC,QAAQ,CAAC;IACrE,IAAI,CAAC,SAAS;QACZ,MAAM,IAAI,MAAM;IAClB;AACF"}},
    {"offset": {"line": 1236, "column": 0}, "map": {"version":3,"sources":["file:///home/hendo420/itsm/app/api/v1/tickets/%5Bid%5D/route.ts"],"sourcesContent":["import { NextRequest, NextResponse } from 'next/server'\nimport { z } from 'zod'\nimport { getTicketById, updateTicket, addTicketComment } from '@/lib/services/ticket-service'\nimport { getAuthContext, requireAuth } from '@/lib/middleware/auth'\nimport { TicketPriority, TicketStatus } from '@prisma/client'\n\nconst idSchema = z.object({\n  id: z.string().uuid(),\n})\n\nconst updateSchema = z.object({\n  subject: z.string().min(3).optional(),\n  description: z.string().min(3).optional(),\n  status: z.nativeEnum(TicketStatus).optional(),\n  priority: z.nativeEnum(TicketPriority).optional(),\n  assigneeId: z.string().uuid().nullable().optional(),\n})\n\nconst commentSchema = z.object({\n  body: z.string().min(1),\n})\n\nexport async function GET(_: NextRequest, { params }: { params: Promise<{ id: string }> }) {\n  try {\n    const { id } = idSchema.parse(await params)\n    const ticket = await getTicketById(id)\n    if (!ticket) {\n      return NextResponse.json({ success: false, error: { code: 'NOT_FOUND', message: 'Ticket not found' } }, { status: 404 })\n    }\n    return NextResponse.json({ success: true, data: ticket })\n  } catch (error) {\n    if (error instanceof z.ZodError) {\n      return NextResponse.json(\n        { success: false, error: { code: 'VALIDATION_ERROR', details: error.flatten() } },\n        { status: 400 }\n      )\n    }\n    return NextResponse.json(\n      { success: false, error: { code: 'INTERNAL_ERROR', message: 'Unable to fetch ticket' } },\n      { status: 500 }\n    )\n  }\n}\n\nexport async function PATCH(request: NextRequest, { params }: { params: Promise<{ id: string }> }) {\n  try {\n    const auth = await getAuthContext(request)\n    requireAuth(auth)\n\n    const { id } = idSchema.parse(await params)\n    const body = await request.json()\n    const validated = updateSchema.parse(body)\n\n    const updated = await updateTicket(id, validated)\n    return NextResponse.json({ success: true, data: updated })\n  } catch (error) {\n    if (error instanceof z.ZodError) {\n      return NextResponse.json(\n        { success: false, error: { code: 'VALIDATION_ERROR', details: error.flatten() } },\n        { status: 400 }\n      )\n    }\n    if (error instanceof Error && error.message === 'Unauthorized') {\n      return NextResponse.json(\n        { success: false, error: { code: 'UNAUTHORIZED', message: 'Authentication required' } },\n        { status: 401 }\n      )\n    }\n    return NextResponse.json(\n      { success: false, error: { code: 'INTERNAL_ERROR', message: 'Unable to update ticket' } },\n      { status: 500 }\n    )\n  }\n}\n\nexport async function POST(request: NextRequest, { params }: { params: Promise<{ id: string }> }) {\n  try {\n    const auth = await getAuthContext(request)\n    requireAuth(auth)\n\n    const { id } = idSchema.parse(await params)\n    const body = await request.json()\n    const validated = commentSchema.parse(body)\n\n    const comment = await addTicketComment({\n      ticketId: id,\n      authorId: auth.user.id,\n      body: validated.body,\n    })\n\n    return NextResponse.json({ success: true, data: comment }, { status: 201 })\n  } catch (error) {\n    if (error instanceof z.ZodError) {\n      return NextResponse.json(\n        { success: false, error: { code: 'VALIDATION_ERROR', details: error.flatten() } },\n        { status: 400 }\n      )\n    }\n    if (error instanceof Error && error.message === 'Unauthorized') {\n      return NextResponse.json(\n        { success: false, error: { code: 'UNAUTHORIZED', message: 'Authentication required' } },\n        { status: 401 }\n      )\n    }\n    return NextResponse.json(\n      { success: false, error: { code: 'INTERNAL_ERROR', message: 'Unable to add comment' } },\n      { status: 500 }\n    )\n  }\n}\n\n"],"names":[],"mappings":"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"}}]
}