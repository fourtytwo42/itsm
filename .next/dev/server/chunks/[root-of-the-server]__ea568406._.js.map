{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 70, "column": 0}, "map": {"version":3,"sources":["file:///home/hendo420/itsm/lib/jwt.ts"],"sourcesContent":["import jwt from 'jsonwebtoken'\n\nconst JWT_SECRET = process.env.JWT_SECRET || 'default-secret-change-in-production'\nconst JWT_EXPIRES_IN = process.env.JWT_EXPIRES_IN || '3d'\nconst JWT_REFRESH_SECRET = process.env.JWT_REFRESH_SECRET || 'default-refresh-secret-change-in-production'\nconst JWT_REFRESH_EXPIRES_IN = process.env.JWT_REFRESH_EXPIRES_IN || '30d'\n\nexport interface TokenPayload {\n  userId: string\n  email: string\n  roles: string[]\n}\n\nexport interface RefreshTokenPayload {\n  userId: string\n  email: string\n}\n\nexport function signToken(payload: TokenPayload): string {\n  return jwt.sign(payload, JWT_SECRET, {\n    expiresIn: JWT_EXPIRES_IN,\n    algorithm: 'HS256',\n  })\n}\n\nexport function verifyToken(token: string): TokenPayload {\n  try {\n    const decoded = jwt.verify(token, JWT_SECRET, {\n      algorithms: ['HS256'],\n    }) as TokenPayload\n    return decoded\n  } catch (error) {\n    throw new Error('Invalid or expired token')\n  }\n}\n\nexport function signRefreshToken(payload: RefreshTokenPayload): string {\n  return jwt.sign(payload, JWT_REFRESH_SECRET, {\n    expiresIn: JWT_REFRESH_EXPIRES_IN,\n    algorithm: 'HS256',\n  })\n}\n\nexport function verifyRefreshToken(token: string): RefreshTokenPayload {\n  try {\n    const decoded = jwt.verify(token, JWT_REFRESH_SECRET, {\n      algorithms: ['HS256'],\n    }) as RefreshTokenPayload\n    return decoded\n  } catch (error) {\n    throw new Error('Invalid or expired refresh token')\n  }\n}\n\n"],"names":[],"mappings":";;;;;;;;;;AAAA;;AAEA,MAAM,aAAa,QAAQ,GAAG,CAAC,UAAU,IAAI;AAC7C,MAAM,iBAAiB,QAAQ,GAAG,CAAC,cAAc,IAAI;AACrD,MAAM,qBAAqB,QAAQ,GAAG,CAAC,kBAAkB,IAAI;AAC7D,MAAM,yBAAyB,QAAQ,GAAG,CAAC,sBAAsB,IAAI;AAa9D,SAAS,UAAU,OAAqB;IAC7C,OAAO,kJAAG,CAAC,IAAI,CAAC,SAAS,YAAY;QACnC,WAAW;QACX,WAAW;IACb;AACF;AAEO,SAAS,YAAY,KAAa;IACvC,IAAI;QACF,MAAM,UAAU,kJAAG,CAAC,MAAM,CAAC,OAAO,YAAY;YAC5C,YAAY;gBAAC;aAAQ;QACvB;QACA,OAAO;IACT,EAAE,OAAO,OAAO;QACd,MAAM,IAAI,MAAM;IAClB;AACF;AAEO,SAAS,iBAAiB,OAA4B;IAC3D,OAAO,kJAAG,CAAC,IAAI,CAAC,SAAS,oBAAoB;QAC3C,WAAW;QACX,WAAW;IACb;AACF;AAEO,SAAS,mBAAmB,KAAa;IAC9C,IAAI;QACF,MAAM,UAAU,kJAAG,CAAC,MAAM,CAAC,OAAO,oBAAoB;YACpD,YAAY;gBAAC;aAAQ;QACvB;QACA,OAAO;IACT,EAAE,OAAO,OAAO;QACd,MAAM,IAAI,MAAM;IAClB;AACF"}},
    {"offset": {"line": 132, "column": 0}, "map": {"version":3,"sources":["file:///home/hendo420/itsm/lib/prisma.ts"],"sourcesContent":["import { PrismaClient } from '@prisma/client'\n\nconst globalForPrisma = globalThis as unknown as {\n  prisma: PrismaClient | undefined\n}\n\nconst prisma = globalForPrisma.prisma ?? new PrismaClient({\n  log: process.env.NODE_ENV === 'development' ? ['query', 'error', 'warn'] : ['error'],\n})\n\nif (process.env.NODE_ENV !== 'production') {\n  globalForPrisma.prisma = prisma\n}\n\nexport default prisma\n"],"names":[],"mappings":";;;;AAAA;;AAEA,MAAM,kBAAkB;AAIxB,MAAM,SAAS,gBAAgB,MAAM,IAAI,IAAI,6IAAY,CAAC;IACxD,KAAK,uCAAyC;QAAC;QAAS;QAAS;KAAO,GAAG;AAC7E;AAEA,wCAA2C;IACzC,gBAAgB,MAAM,GAAG;AAC3B;uCAEe"}},
    {"offset": {"line": 154, "column": 0}, "map": {"version":3,"sources":["file:///home/hendo420/itsm/lib/auth.ts"],"sourcesContent":["import bcrypt from 'bcryptjs'\nimport prisma from './prisma'\nimport { signToken, signRefreshToken, type TokenPayload } from './jwt'\nimport { RoleName } from '@prisma/client'\n\nconst SALT_ROUNDS = 12\n\nexport async function hashPassword(password: string): Promise<string> {\n  return bcrypt.hash(password, SALT_ROUNDS)\n}\n\nexport async function verifyPassword(password: string, hash: string): Promise<boolean> {\n  return bcrypt.compare(password, hash)\n}\n\nexport interface LoginCredentials {\n  email: string\n  password: string\n}\n\nexport interface AuthResult {\n  user: {\n    id: string\n    email: string\n    firstName: string | null\n    lastName: string | null\n    roles: string[]\n  }\n  accessToken: string\n  refreshToken: string\n}\n\nexport async function authenticateUser(credentials: LoginCredentials): Promise<AuthResult> {\n  const { email, password } = credentials\n\n  // Find user with roles\n  const user = await prisma.user.findUnique({\n    where: { email },\n    include: {\n      roles: {\n        include: {\n          role: true,\n        },\n      },\n    },\n  })\n\n  if (!user || !user.passwordHash) {\n    throw new Error('Invalid email or password')\n  }\n\n  if (!user.isActive) {\n    throw new Error('Account is inactive')\n  }\n\n  const isValidPassword = await verifyPassword(password, user.passwordHash)\n  if (!isValidPassword) {\n    throw new Error('Invalid email or password')\n  }\n\n  // Update last login\n  await prisma.user.update({\n    where: { id: user.id },\n    data: { updatedAt: new Date() },\n  })\n\n  // Get user roles\n  const roles = user.roles.map((ur) => ur.role.name)\n\n  // Generate tokens\n  const tokenPayload: TokenPayload = {\n    userId: user.id,\n    email: user.email,\n    roles,\n  }\n\n  const accessToken = signToken(tokenPayload)\n  const refreshToken = signRefreshToken({\n    userId: user.id,\n    email: user.email,\n  })\n\n  return {\n    user: {\n      id: user.id,\n      email: user.email,\n      firstName: user.firstName,\n      lastName: user.lastName,\n      roles,\n    },\n    accessToken,\n    refreshToken,\n  }\n}\n\nexport interface RegisterData {\n  email: string\n  password: string\n  firstName?: string\n  lastName?: string\n}\n\nexport async function registerUser(data: RegisterData): Promise<AuthResult> {\n  const { email, password, firstName, lastName } = data\n\n  // Check if user already exists\n  const existingUser = await prisma.user.findUnique({\n    where: { email },\n  })\n\n  if (existingUser) {\n    throw new Error('User with this email already exists')\n  }\n\n  // Hash password\n  const passwordHash = await hashPassword(password)\n\n  // Create user with END_USER role by default\n  const user = await prisma.user.create({\n    data: {\n      email,\n      passwordHash,\n      firstName,\n      lastName,\n      roles: {\n        create: {\n          role: {\n            connect: {\n              name: RoleName.END_USER,\n            },\n          },\n        },\n      },\n    },\n    include: {\n      roles: {\n        include: {\n          role: true,\n        },\n      },\n    },\n  })\n\n  // Get user roles\n  const roles = user.roles.map((ur) => ur.role.name)\n\n  // Generate tokens\n  const tokenPayload: TokenPayload = {\n    userId: user.id,\n    email: user.email,\n    roles,\n  }\n\n  const accessToken = signToken(tokenPayload)\n  const refreshToken = signRefreshToken({\n    userId: user.id,\n    email: user.email,\n  })\n\n  return {\n    user: {\n      id: user.id,\n      email: user.email,\n      firstName: user.firstName,\n      lastName: user.lastName,\n      roles,\n    },\n    accessToken,\n    refreshToken,\n  }\n}\n\nexport async function getUserById(userId: string) {\n  return prisma.user.findUnique({\n    where: { id: userId },\n    include: {\n      roles: {\n        include: {\n          role: true,\n        },\n      },\n    },\n  })\n}\n\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 321, "column": 0}, "map": {"version":3,"sources":["file:///home/hendo420/itsm/lib/middleware/auth.ts"],"sourcesContent":["import { NextRequest } from 'next/server'\nimport { verifyToken, type TokenPayload } from '@/lib/jwt'\nimport { getUserById } from '@/lib/auth'\n\nexport interface AuthContext {\n  user: {\n    id: string\n    email: string\n    roles: string[]\n  }\n}\n\nexport async function getAuthContext(request: NextRequest): Promise<AuthContext | null> {\n  try {\n    const authHeader = request.headers.get('authorization')\n    \n    if (!authHeader || !authHeader.startsWith('Bearer ')) {\n      return null\n    }\n\n    const token = authHeader.substring(7)\n    const payload = verifyToken(token)\n\n    const user = await getUserById(payload.userId)\n    if (!user || !user.isActive) {\n      return null\n    }\n\n    const roles = user.roles.map((ur) => ur.role.name)\n\n    return {\n      user: {\n        id: user.id,\n        email: user.email,\n        roles,\n      },\n    }\n  } catch (error) {\n    return null\n  }\n}\n\nexport function requireAuth(authContext: AuthContext | null): asserts authContext is AuthContext {\n  if (!authContext) {\n    throw new Error('Unauthorized')\n  }\n}\n\nexport function requireRole(authContext: AuthContext, role: string): void {\n  requireAuth(authContext)\n  if (!authContext.user.roles.includes(role)) {\n    throw new Error('Forbidden: Insufficient permissions')\n  }\n}\n\nexport function requireAnyRole(authContext: AuthContext, roles: string[]): void {\n  requireAuth(authContext)\n  const hasRole = roles.some((role) => authContext.user.roles.includes(role))\n  if (!hasRole) {\n    throw new Error('Forbidden: Insufficient permissions')\n  }\n}\n\n"],"names":[],"mappings":";;;;;;;;;;AACA;AACA;;;AAUO,eAAe,eAAe,OAAoB;IACvD,IAAI;QACF,MAAM,aAAa,QAAQ,OAAO,CAAC,GAAG,CAAC;QAEvC,IAAI,CAAC,cAAc,CAAC,WAAW,UAAU,CAAC,YAAY;YACpD,OAAO;QACT;QAEA,MAAM,QAAQ,WAAW,SAAS,CAAC;QACnC,MAAM,UAAU,IAAA,2HAAW,EAAC;QAE5B,MAAM,OAAO,MAAM,IAAA,4HAAW,EAAC,QAAQ,MAAM;QAC7C,IAAI,CAAC,QAAQ,CAAC,KAAK,QAAQ,EAAE;YAC3B,OAAO;QACT;QAEA,MAAM,QAAQ,KAAK,KAAK,CAAC,GAAG,CAAC,CAAC,KAAO,GAAG,IAAI,CAAC,IAAI;QAEjD,OAAO;YACL,MAAM;gBACJ,IAAI,KAAK,EAAE;gBACX,OAAO,KAAK,KAAK;gBACjB;YACF;QACF;IACF,EAAE,OAAO,OAAO;QACd,OAAO;IACT;AACF;AAEO,SAAS,YAAY,WAA+B;IACzD,IAAI,CAAC,aAAa;QAChB,MAAM,IAAI,MAAM;IAClB;AACF;AAEO,SAAS,YAAY,WAAwB,EAAE,IAAY;IAChE,YAAY;IACZ,IAAI,CAAC,YAAY,IAAI,CAAC,KAAK,CAAC,QAAQ,CAAC,OAAO;QAC1C,MAAM,IAAI,MAAM;IAClB;AACF;AAEO,SAAS,eAAe,WAAwB,EAAE,KAAe;IACtE,YAAY;IACZ,MAAM,UAAU,MAAM,IAAI,CAAC,CAAC,OAAS,YAAY,IAAI,CAAC,KAAK,CAAC,QAAQ,CAAC;IACrE,IAAI,CAAC,SAAS;QACZ,MAAM,IAAI,MAAM;IAClB;AACF"}},
    {"offset": {"line": 423, "column": 0}, "map": {"version":3,"sources":["file:///home/hendo420/itsm/lib/websocket/server.ts"],"sourcesContent":["import { WebSocketServer, WebSocket } from 'ws'\nimport { verifyToken, type TokenPayload } from '@/lib/jwt'\nimport { getUserById } from '@/lib/auth'\nimport type { Server as HTTPServer } from 'http'\n\nexport interface WebSocketClient {\n  ws: WebSocket\n  userId: string\n  email: string\n  roles: string[]\n  subscriptions: Set<string> // Set of ticket IDs or other resource IDs\n}\n\nexport interface WebSocketMessage {\n  event: string\n  data?: any\n  error?: string\n}\n\nclass WSServer {\n  private wss: WebSocketServer | null = null\n  private clients: Map<string, WebSocketClient> = new Map() // userId -> client\n  private ticketSubscriptions: Map<string, Set<string>> = new Map() // ticketId -> Set of userIds\n\n  initialize(server: HTTPServer) {\n    this.wss = new WebSocketServer({ server, path: '/ws' })\n\n    this.wss.on('connection', async (ws: WebSocket, req) => {\n      try {\n        // Extract token from query string or Authorization header\n        const url = new URL(req.url || '', `http://${req.headers.host}`)\n        const token = url.searchParams.get('token') || this.extractTokenFromHeaders(req.headers)\n\n        if (!token) {\n          ws.close(1008, 'Authentication required')\n          return\n        }\n\n        // Verify JWT token\n        const payload = verifyToken(token)\n        const user = await getUserById(payload.userId)\n\n        if (!user || !user.isActive) {\n          ws.close(1008, 'Invalid or inactive user')\n          return\n        }\n\n        const roles = user.roles.map((ur) => ur.role.name)\n\n        const client: WebSocketClient = {\n          ws,\n          userId: user.id,\n          email: user.email,\n          roles,\n          subscriptions: new Set(),\n        }\n\n        // Store client\n        this.clients.set(user.id, client)\n\n        // Send connection confirmation\n        this.sendToClient(client, {\n          event: 'connected',\n          data: { userId: user.id, email: user.email },\n        })\n\n        // Handle messages\n        ws.on('message', (data: Buffer) => {\n          try {\n            const message: WebSocketMessage = JSON.parse(data.toString())\n            this.handleMessage(client, message)\n          } catch (error) {\n            this.sendToClient(client, {\n              event: 'error',\n              error: 'Invalid message format',\n            })\n          }\n        })\n\n        // Handle disconnect\n        ws.on('close', () => {\n          this.handleDisconnect(client)\n        })\n\n        // Handle errors\n        ws.on('error', (error) => {\n          console.error('WebSocket error:', error)\n          this.handleDisconnect(client)\n        })\n      } catch (error: any) {\n        console.error('WebSocket connection error:', error)\n        ws.close(1008, error.message || 'Connection failed')\n      }\n    })\n\n    console.log('WebSocket server initialized on /ws')\n  }\n\n  private extractTokenFromHeaders(headers: any): string | null {\n    const authHeader = headers.authorization || headers.Authorization\n    if (authHeader && typeof authHeader === 'string' && authHeader.startsWith('Bearer ')) {\n      return authHeader.substring(7)\n    }\n    return null\n  }\n\n  private handleMessage(client: WebSocketClient, message: WebSocketMessage) {\n    switch (message.event) {\n      case 'subscribe:ticket':\n        if (message.data?.ticketId) {\n          client.subscriptions.add(`ticket:${message.data.ticketId}`)\n          this.subscribeToTicket(message.data.ticketId, client.userId)\n          this.sendToClient(client, {\n            event: 'subscribed',\n            data: { resource: `ticket:${message.data.ticketId}` },\n          })\n        }\n        break\n\n      case 'unsubscribe:ticket':\n        if (message.data?.ticketId) {\n          client.subscriptions.delete(`ticket:${message.data.ticketId}`)\n          this.unsubscribeFromTicket(message.data.ticketId, client.userId)\n          this.sendToClient(client, {\n            event: 'unsubscribed',\n            data: { resource: `ticket:${message.data.ticketId}` },\n          })\n        }\n        break\n\n      case 'ping':\n        this.sendToClient(client, { event: 'pong' })\n        break\n\n      default:\n        this.sendToClient(client, {\n          event: 'error',\n          error: `Unknown event: ${message.event}`,\n        })\n    }\n  }\n\n  private subscribeToTicket(ticketId: string, userId: string) {\n    if (!this.ticketSubscriptions.has(ticketId)) {\n      this.ticketSubscriptions.set(ticketId, new Set())\n    }\n    this.ticketSubscriptions.get(ticketId)!.add(userId)\n  }\n\n  private unsubscribeFromTicket(ticketId: string, userId: string) {\n    const subscribers = this.ticketSubscriptions.get(ticketId)\n    if (subscribers) {\n      subscribers.delete(userId)\n      if (subscribers.size === 0) {\n        this.ticketSubscriptions.delete(ticketId)\n      }\n    }\n  }\n\n  private handleDisconnect(client: WebSocketClient) {\n    // Remove all ticket subscriptions\n    for (const sub of client.subscriptions) {\n      if (sub.startsWith('ticket:')) {\n        const ticketId = sub.replace('ticket:', '')\n        this.unsubscribeFromTicket(ticketId, client.userId)\n      }\n    }\n\n    this.clients.delete(client.userId)\n  }\n\n  private sendToClient(client: WebSocketClient, message: WebSocketMessage) {\n    if (client.ws.readyState === WebSocket.OPEN) {\n      client.ws.send(JSON.stringify(message))\n    }\n  }\n\n  // Public methods for broadcasting events\n  broadcastToUser(userId: string, event: string, data: any) {\n    const client = this.clients.get(userId)\n    if (client) {\n      this.sendToClient(client, { event, data })\n    }\n  }\n\n  broadcastToTicketSubscribers(ticketId: string, event: string, data: any) {\n    const subscribers = this.ticketSubscriptions.get(ticketId)\n    if (subscribers) {\n      subscribers.forEach((userId) => {\n        this.broadcastToUser(userId, event, data)\n      })\n    }\n  }\n\n  broadcastToAll(event: string, data: any) {\n    this.clients.forEach((client) => {\n      this.sendToClient(client, { event, data })\n    })\n  }\n\n  broadcastToRoles(roles: string[], event: string, data: any) {\n    this.clients.forEach((client) => {\n      if (roles.some((role) => client.roles.includes(role))) {\n        this.sendToClient(client, { event, data })\n      }\n    })\n  }\n\n  getClientCount(): number {\n    return this.clients.size\n  }\n\n  getTicketSubscriberCount(ticketId: string): number {\n    return this.ticketSubscriptions.get(ticketId)?.size || 0\n  }\n}\n\n// Singleton instance\nexport const wsServer = new WSServer()\n\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 631, "column": 0}, "map": {"version":3,"sources":["file:///home/hendo420/itsm/lib/services/notification-service.ts"],"sourcesContent":["import prisma from '@/lib/prisma'\nimport { NotificationType, NotificationStatus } from '@prisma/client'\nimport { wsServer } from '@/lib/websocket/server'\n\nexport interface CreateNotificationParams {\n  userId: string\n  type: NotificationType\n  title: string\n  message: string\n  link?: string\n  metadata?: Record<string, any>\n}\n\nexport async function createNotification(params: CreateNotificationParams) {\n  const notification = await prisma.notification.create({\n    data: {\n      userId: params.userId,\n      type: params.type,\n      title: params.title,\n      message: params.message,\n      link: params.link,\n      metadata: params.metadata || {},\n    },\n  })\n\n  // Check user's notification preferences\n  const preferences = await prisma.notificationPreference.findUnique({\n    where: { userId: params.userId },\n  })\n\n  // Only send real-time notification if enabled\n  const shouldNotify = preferences\n    ? getPreferenceForType(preferences, params.type)\n    : true // Default to true if no preferences set\n\n  if (shouldNotify) {\n    // Send via WebSocket\n    wsServer.broadcastToUser(params.userId, 'notification:new', {\n      notification: {\n        id: notification.id,\n        type: notification.type,\n        title: notification.title,\n        message: notification.message,\n        link: notification.link,\n        createdAt: notification.createdAt,\n      },\n    })\n  }\n\n  return notification\n}\n\nfunction getPreferenceForType(\n  preferences: {\n    ticketCreated: boolean\n    ticketUpdated: boolean\n    ticketAssigned: boolean\n    ticketComment: boolean\n    changeRequestCreated: boolean\n    changeRequestApproved: boolean\n    changeRequestRejected: boolean\n    slaBreached: boolean\n    escalation: boolean\n  },\n  type: NotificationType\n): boolean {\n  switch (type) {\n    case NotificationType.TICKET_CREATED:\n      return preferences.ticketCreated\n    case NotificationType.TICKET_UPDATED:\n      return preferences.ticketUpdated\n    case NotificationType.TICKET_ASSIGNED:\n      return preferences.ticketAssigned\n    case NotificationType.TICKET_COMMENT:\n      return preferences.ticketComment\n    case NotificationType.CHANGE_REQUEST_CREATED:\n      return preferences.changeRequestCreated\n    case NotificationType.CHANGE_REQUEST_APPROVED:\n      return preferences.changeRequestApproved\n    case NotificationType.CHANGE_REQUEST_REJECTED:\n      return preferences.changeRequestRejected\n    case NotificationType.SLA_BREACHED:\n      return preferences.slaBreached\n    case NotificationType.ESCALATION:\n      return preferences.escalation\n    default:\n      return true\n  }\n}\n\nexport async function getNotifications(userId: string, options?: { limit?: number; unreadOnly?: boolean }) {\n  const where: any = { userId }\n  if (options?.unreadOnly) {\n    where.status = NotificationStatus.UNREAD\n  }\n\n  const notifications = await prisma.notification.findMany({\n    where,\n    orderBy: { createdAt: 'desc' },\n    take: options?.limit || 50,\n  })\n\n  return notifications\n}\n\nexport async function markAsRead(notificationId: string, userId: string) {\n  const notification = await prisma.notification.updateMany({\n    where: {\n      id: notificationId,\n      userId, // Ensure user owns the notification\n    },\n    data: {\n      status: NotificationStatus.READ,\n      readAt: new Date(),\n    },\n  })\n\n  return notification.count > 0\n}\n\nexport async function markAllAsRead(userId: string) {\n  await prisma.notification.updateMany({\n    where: {\n      userId,\n      status: NotificationStatus.UNREAD,\n    },\n    data: {\n      status: NotificationStatus.READ,\n      readAt: new Date(),\n    },\n  })\n}\n\nexport async function deleteNotification(notificationId: string, userId: string) {\n  const notification = await prisma.notification.deleteMany({\n    where: {\n      id: notificationId,\n      userId, // Ensure user owns the notification\n    },\n  })\n\n  return notification.count > 0\n}\n\nexport async function getUnreadCount(userId: string): Promise<number> {\n  return prisma.notification.count({\n    where: {\n      userId,\n      status: NotificationStatus.UNREAD,\n    },\n  })\n}\n\nexport async function getNotificationPreferences(userId: string) {\n  let preferences = await prisma.notificationPreference.findUnique({\n    where: { userId },\n  })\n\n  // Create default preferences if they don't exist\n  if (!preferences) {\n    preferences = await prisma.notificationPreference.create({\n      data: {\n        userId,\n        emailEnabled: true,\n        pushEnabled: true,\n        ticketCreated: true,\n        ticketUpdated: true,\n        ticketAssigned: true,\n        ticketComment: true,\n        changeRequestCreated: true,\n        changeRequestApproved: true,\n        changeRequestRejected: true,\n        slaBreached: true,\n        escalation: true,\n      },\n    })\n  }\n\n  return preferences\n}\n\nexport async function updateNotificationPreferences(\n  userId: string,\n  updates: Partial<{\n    emailEnabled: boolean\n    pushEnabled: boolean\n    ticketCreated: boolean\n    ticketUpdated: boolean\n    ticketAssigned: boolean\n    ticketComment: boolean\n    changeRequestCreated: boolean\n    changeRequestApproved: boolean\n    changeRequestRejected: boolean\n    slaBreached: boolean\n    escalation: boolean\n  }>\n) {\n  const preferences = await prisma.notificationPreference.upsert({\n    where: { userId },\n    update: updates,\n    create: {\n      userId,\n      emailEnabled: true,\n      pushEnabled: true,\n      ticketCreated: true,\n      ticketUpdated: true,\n      ticketAssigned: true,\n      ticketComment: true,\n      changeRequestCreated: true,\n      changeRequestApproved: true,\n      changeRequestRejected: true,\n      slaBreached: true,\n      escalation: true,\n      ...updates,\n    },\n  })\n\n  return preferences\n}\n\n// Helper functions to notify about ticket events\nexport async function notifyTicketCreated(ticketId: string, ticketNumber: string, assigneeId: string | null) {\n  if (assigneeId) {\n    await createNotification({\n      userId: assigneeId,\n      type: NotificationType.TICKET_ASSIGNED,\n      title: 'New Ticket Assigned',\n      message: `Ticket ${ticketNumber} has been assigned to you.`,\n      link: `/tickets/${ticketId}`,\n      metadata: { ticketId, ticketNumber },\n    })\n  }\n}\n\nexport async function notifyTicketUpdated(\n  ticketId: string,\n  ticketNumber: string,\n  changes: Record<string, any>,\n  userIds: string[]\n) {\n  for (const userId of userIds) {\n    await createNotification({\n      userId,\n      type: NotificationType.TICKET_UPDATED,\n      title: 'Ticket Updated',\n      message: `Ticket ${ticketNumber} has been updated.`,\n      link: `/tickets/${ticketId}`,\n      metadata: { ticketId, ticketNumber, changes },\n    })\n  }\n}\n\nexport async function notifyTicketAssigned(ticketId: string, ticketNumber: string, assigneeId: string) {\n  await createNotification({\n    userId: assigneeId,\n    type: NotificationType.TICKET_ASSIGNED,\n    title: 'Ticket Assigned',\n    message: `Ticket ${ticketNumber} has been assigned to you.`,\n    link: `/tickets/${ticketId}`,\n    metadata: { ticketId, ticketNumber },\n  })\n}\n\nexport async function notifyTicketComment(ticketId: string, ticketNumber: string, commentAuthorId: string, userIds: string[]) {\n  // Don't notify the comment author\n  const recipients = userIds.filter((id) => id !== commentAuthorId)\n\n  for (const userId of recipients) {\n    await createNotification({\n      userId,\n      type: NotificationType.TICKET_COMMENT,\n      title: 'New Comment',\n      message: `A new comment was added to ticket ${ticketNumber}.`,\n      link: `/tickets/${ticketId}`,\n      metadata: { ticketId, ticketNumber, commentAuthorId },\n    })\n  }\n}\n\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 897, "column": 0}, "map": {"version":3,"sources":["file:///home/hendo420/itsm/app/api/v1/notifications/route.ts"],"sourcesContent":["import { NextRequest, NextResponse } from 'next/server'\nimport { getAuthContext } from '@/lib/middleware/auth'\nimport {\n  getNotifications,\n  getUnreadCount,\n  markAllAsRead,\n  getNotificationPreferences,\n  updateNotificationPreferences,\n} from '@/lib/services/notification-service'\n\nexport async function GET(req: NextRequest) {\n  try {\n    const authContext = await getAuthContext(req)\n    if (!authContext) {\n      return NextResponse.json({ success: false, error: 'Unauthorized' }, { status: 401 })\n    }\n    const { user } = authContext\n\n    const { searchParams } = new URL(req.url)\n    const limit = parseInt(searchParams.get('limit') || '50', 10)\n    const unreadOnly = searchParams.get('unreadOnly') === 'true'\n\n    const notifications = await getNotifications(user.id, { limit, unreadOnly })\n    const unreadCount = await getUnreadCount(user.id)\n\n    return NextResponse.json({\n      success: true,\n      data: {\n        notifications,\n        unreadCount,\n      },\n    })\n  } catch (error: any) {\n    console.error('Get notifications error:', error)\n    return NextResponse.json(\n      { success: false, error: { code: 'NOTIFICATIONS_ERROR', message: error.message } },\n      { status: 500 }\n    )\n  }\n}\n\nexport async function PUT(req: NextRequest) {\n  try {\n    const authContext = await getAuthContext(req)\n    if (!authContext) {\n      return NextResponse.json({ success: false, error: 'Unauthorized' }, { status: 401 })\n    }\n    const { user } = authContext\n\n    const body = await req.json()\n    if (body.action === 'markAllAsRead') {\n      await markAllAsRead(user.id)\n      return NextResponse.json({ success: true, data: { message: 'All notifications marked as read' } })\n    }\n\n    return NextResponse.json({ success: false, error: 'Invalid action' }, { status: 400 })\n  } catch (error: any) {\n    console.error('Update notifications error:', error)\n    return NextResponse.json(\n      { success: false, error: { code: 'NOTIFICATIONS_ERROR', message: error.message } },\n      { status: 500 }\n    )\n  }\n}\n\n"],"names":[],"mappings":";;;;;;AAAA;AACA;AACA;;;;AAQO,eAAe,IAAI,GAAgB;IACxC,IAAI;QACF,MAAM,cAAc,MAAM,IAAA,6IAAc,EAAC;QACzC,IAAI,CAAC,aAAa;YAChB,OAAO,gJAAY,CAAC,IAAI,CAAC;gBAAE,SAAS;gBAAO,OAAO;YAAe,GAAG;gBAAE,QAAQ;YAAI;QACpF;QACA,MAAM,EAAE,IAAI,EAAE,GAAG;QAEjB,MAAM,EAAE,YAAY,EAAE,GAAG,IAAI,IAAI,IAAI,GAAG;QACxC,MAAM,QAAQ,SAAS,aAAa,GAAG,CAAC,YAAY,MAAM;QAC1D,MAAM,aAAa,aAAa,GAAG,CAAC,kBAAkB;QAEtD,MAAM,gBAAgB,MAAM,IAAA,gKAAgB,EAAC,KAAK,EAAE,EAAE;YAAE;YAAO;QAAW;QAC1E,MAAM,cAAc,MAAM,IAAA,8JAAc,EAAC,KAAK,EAAE;QAEhD,OAAO,gJAAY,CAAC,IAAI,CAAC;YACvB,SAAS;YACT,MAAM;gBACJ;gBACA;YACF;QACF;IACF,EAAE,OAAO,OAAY;QACnB,QAAQ,KAAK,CAAC,4BAA4B;QAC1C,OAAO,gJAAY,CAAC,IAAI,CACtB;YAAE,SAAS;YAAO,OAAO;gBAAE,MAAM;gBAAuB,SAAS,MAAM,OAAO;YAAC;QAAE,GACjF;YAAE,QAAQ;QAAI;IAElB;AACF;AAEO,eAAe,IAAI,GAAgB;IACxC,IAAI;QACF,MAAM,cAAc,MAAM,IAAA,6IAAc,EAAC;QACzC,IAAI,CAAC,aAAa;YAChB,OAAO,gJAAY,CAAC,IAAI,CAAC;gBAAE,SAAS;gBAAO,OAAO;YAAe,GAAG;gBAAE,QAAQ;YAAI;QACpF;QACA,MAAM,EAAE,IAAI,EAAE,GAAG;QAEjB,MAAM,OAAO,MAAM,IAAI,IAAI;QAC3B,IAAI,KAAK,MAAM,KAAK,iBAAiB;YACnC,MAAM,IAAA,6JAAa,EAAC,KAAK,EAAE;YAC3B,OAAO,gJAAY,CAAC,IAAI,CAAC;gBAAE,SAAS;gBAAM,MAAM;oBAAE,SAAS;gBAAmC;YAAE;QAClG;QAEA,OAAO,gJAAY,CAAC,IAAI,CAAC;YAAE,SAAS;YAAO,OAAO;QAAiB,GAAG;YAAE,QAAQ;QAAI;IACtF,EAAE,OAAO,OAAY;QACnB,QAAQ,KAAK,CAAC,+BAA+B;QAC7C,OAAO,gJAAY,CAAC,IAAI,CACtB;YAAE,SAAS;YAAO,OAAO;gBAAE,MAAM;gBAAuB,SAAS,MAAM,OAAO;YAAC;QAAE,GACjF;YAAE,QAAQ;QAAI;IAElB;AACF"}}]
}